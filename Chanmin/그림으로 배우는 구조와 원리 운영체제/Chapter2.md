# 02 운영체제의 개념과 발전 목적

## 1. 운영체제의 개념

- 컴퓨터 시스템은 크게 사용자, 소프트웨어, 하드웨어로 구성
- 운영체제는 사용자가 하드웨어에 접근할 수 있는 유일한 수단
- 사용자가 응용 프로그램을 실행할 수 있는 기반 환경을 제공
- 컴퓨터를 편리하게 사용할 수 있도록 도움
- 하드웨어를 효율적으로 사용할 수 있도록 다양한 기능을 제공하는 소프트웨어

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-1.jpg" alt="그림 2-1 컴퓨터 시스템의 구성 요소와 운영체제" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-1 컴퓨터 시스템의 구성 요소와 운영체제<br>

- 사용자<br>:
  어떤 일을 수행하려고 컴퓨터를 사용하는 사람이나 장치, 다른 컴퓨터를 의미한다.

<br>

- 소프트웨어<br>:
  컴퓨터가 기능을 수행하는 데 필요한 모든 프로그램을 의미한다. 시스템 소프트웨어, 유틸리티, 응용 프로그램 등으로 구성된다.

  - 시스템 소프트웨어<br>:
  컴퓨터 자원을 관리하고 응용 프로그램의 실행을 지원하여 컴퓨터를 제어하는 프로그램이다. 운영체제를 비롯해 장치 드라이버 등으로 구성된다.

  - 유틸리티<br>:
  응용 프로그램보다 작지만 컴퓨터의 여러 처리 과정을 보조하여 시스템을 유지하고 성능을 개선하는 프로그램으로, 운영체제를 돕는 역할 을 한다.

  - 응용 프로그램<br>:
  운영체제는 다양한 응용 프로그램이 하드웨어, 즉 컴퓨터 자원을 효율적으로 사용할 수 있도록 관리하고 조정하는 역할을 한다.

<br>

- 하드웨어<br>:
  기본 연산 자원을 제공하는 프로세서(CPU, 중앙처리장치), 메모리, 주변장치 등으로 구성된다.

<br>

- 운영체제는 다양한 응용 프로그램이 하드웨어, 즉 컴퓨터 자원을 효율적으로 사용할 수 있도록 관리하고 조정하는 역할을 한다.

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-2.jpg" alt="그림 2-2 운영체제의 역할" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-2 운영체제의 역할<br>

컴퓨터 자원을 관리하는 면에서 운영체제의 역할은 다음과 같다.

<br>

- 조정자<br>
  - 컴퓨터 시스템은 하드웨어와 소프트웨어, 둘 사이를 오가는 데이터로 운영
  - 운영체제는 이 운영 요소를 적절하게 사용할 수 있또록 제어하면서 사용자와 응용 프로그램 간에 통신을 할 수 있게함
  - 직접 다른 프로그램이 수행하는 특정 작업을 하는 것이 아니라 이 작업을 할 수 있는 환경만 제공하는 조정자

<br>

- 자원 할당자나 관리자<br>
  - 운영체제는 각 응용 프로그램에 필요한 자원을 할당하는 자원 할당자

<br>

- 응용 프로그램과 입출력장치 제어자<br>
  - 운영체제는 다양한 입출력장치와 응용 프로그램을 제어하는 역할
  - 컴퓨터 시스템을 부적절하게 사용하거나 오류가 발생하는 것을 방지하려고 하드웨어 사용을 조정 및 응용 프로그램의 실행을 제어

> 운영체제는 "사용자와 하드웨어 사이의 중간 매개체로 응용 프로그램의 실행을 제어하고, 자원을 할당 및 관리하며, 입출력 제어 및 데이터 관리와 같은 서비스를 제공하는 소프트웨어"로 정의함

<br>

- 하드웨어 및 사용자, 응용 프로그램, 시스템 프로그램 사이에서 인터페이스를 제공
- 프로세서, 메모리, 입출력장치, 통신장치 등 컴퓨터 자원을 효과적으로 활용하려고 조정 및 관리
- 메일 전송, 파일 시스템 검사, 서버 작업 등 높은 수준의 서비스를 처리하는 응용 프로그램을 제어
- 다양한 사용자에게서 컴퓨터 시스템을 보호하려고 입출력을 제어하며 데이터를 관리

<br>

- 운영체제는 커널, 장치 드라이버, 사용자 인터페이스, 시스템 유틸리티 등 4개의 주요 부분으로 구분
  - 커널: 시스템 호출, 인터럽트 및 예외에 응답하는 운영체제의 핵심 구성 요소
  - 커널은 운영체제를 메모리에 적재할 때 제일 먼저 적재하고 운영체제가 종료될 때까지 메모리에 머뭄

<br>

## 2. 운영체제의 발전 목록

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-3.jpg" alt="그림 2-3 운영체제의 발전 목적" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-3 운영체제의 발전 목적<br>

- 편리성: 사용자에게 편리한 환경 제공
  - 운영체제는 사용자가 프로그램을 효율적으로 실행할 수 있는 환경을 제공해야함
    - 프로그램을 편리하게 개발할 수 있는 환경
    - 사용자와 컴퓨터 시스템이 정보 및 명령을 상호 교환할 수 있는 인터페이스

- 효율성: 시스템 성능 향상
  - 사용자가 많은 대형 컴퓨터 시스템에서 특히 중요
  - 운영체제는 각 프로그램을 유기적으로 결합하여 시스템 성능을 향상시켜옴
  - 시스템의 성능의 기준은 다음과 같음
    - 처리량: 단위시간당 처리하는 작업량
    - 지연 및 응답시간: 작업을 완료하기까지 걸린 시간
    - 신뢰도: 하드웨어, 소프트웨어가 실패 없이 주어진 기능을 수행할 수 있는 능력
    - 사용 가능도: 가동률이라고도하며 사용자가 일정 기간 동안 컴퓨터를 실제로 사용한 시간

- 제어 서비스 향상<br>: 서비스를 방해하지 않고 새로운 기능을 도입하고 테스트할 수 있도록 발전해야 함  

# 02. 운영체제의 기능

운영체제의 기능은 크게 자원 관리와 시스템 관리로 분류

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-4.jpg" alt="그림 2-4 운영체제의 기능" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-4 운영체제의 기능<br>

## 1. 자원 관리

컴퓨터 시스템의 메모리, 프로세스, 장치, 파일 등 구성 요소를 자원이라고 하는데, 운영체제는 이 자원을 관리

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-5.jpg" alt="그림 2-5 운영체제의 자원 관리 기능" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-5 운영체제의 자원 관리 기능<br>

## 1.1 메모리 관리

운영체제의 메모리 관리 기능은 메인 메모리와 보조기억장치로 구분

- 메인 메모리 관리
  - 프로세서가 직접 주소로 지정할 수 있는 유일한 메모리
  - 프로그램을 절대 주소로 맵핑하여 메인 메모리에 저장
  - 이를 위한 다양한 메모리 관리 방법 존재
    - 메모리의 어느 부분을 사용하고, 누가 사용하는지 점검
    - 메모리에 저장할 프로세스를 결정
    - 메모리를 할당하고 회수하는 방법 결정

- 보조기억장치 관리
  - 프로그램을 실행하려면 먼저 필요한 데이터와 함께 메인 메모리에 있어야함
  - 대부분의 응용 프로그램은 메인 메모리에 적재할 때까지는 보조기억장치에 저장
  - 따라서 보조기억장치에서 저장 방법은 중요
    - 빈 여유 공간을 관리
    - 새로운 파일을 작성할 때 저장 장소를 할당
    - 메모리 접근 요청을 스케줄링
    - 파일을 생성하고 삭제

## 1.2 프로세스 관리

- 프로세스는 실행 중인 프로그램으로 보통 일괄 처리 작업 하나가 프로세스가 됨
- 하나의 프로세스는 프로세서, 메모리, 파일, 입출력장치와 같은 자원이 있어야 업무를 수행
- 모든 프로세스는 프로세서를 분할 사용하여 병행 수행 가능
- 운영체제는 세부 기능을 수행하여 프로세스를 관리
  - 프로세스와 스레드를 스케줄링
  - 사용자 프로세스와 시스템 프로세스를 생성하고 제거
  - 프로세스를 중지하고 재수행
  - 프로세스 동기화 방법을 제공
  - 프로세스 통신 방법을 제공
  - 교착 상태를 방지하는 방법을 제공

## 1.3 주변장치(입출력장치) 관리

- 운영체제는 장치 드라이브를 사용하여 입출력장치와 상호작용
- 장치 드라이버는 특정 하드웨어장치와 통신할 수 있는 인터페이스를 제공
- 운영체제는 세부 기능을 수행하여 주변장치를 관리
  - 임시 저장 시스템 기능을 제공
  - 일반 장치용 드라이버 인터페이스를 제공
  
## 1.4 파일(데이터) 관리

- 입출력 파일의 위치, 저장과 검색 관리를 의미
- 데이터를 효율적으로 사용할 수 있도록 단일화된 저장 형태를 제공
- 파일을 쉽게 사용하기 위해 디렉토리로 구성
- 다수의 사용자 접근을 제어
- 운영체제는 세부 기능을 수행하여 파일을 관리
  - 파일을 생성하고 삭제
  - 디렉터리를 생성하고 삭제
  - 보조기억장치에 있는 파일을 맵핑
  - 안전한(비휘발성) 저장장치에 파일을 저장

## 2. 시스템 관리

운영체제는 추가로 시스템 보호, 네트워킹, 명령 해석기 등 기능을 지원

## 2.1 시스템 보호(사용자 권한 부여)

- 보호는 컴퓨터 자원에서 프로그램, 프로세스, 사용자의 접근을 제어하는 방법
- 파일 사용 권한 부여, 데이터 암호화 등 서비스를 제공하여 데이터와 시스템을 보안
- 여러 프로세스를 동시에 실행, 네트워크로 파일 공유 사이트 접속 때문에 필요

## 2.2 네트워킹(통신)

- 연결된 프로세서가 통신을 할 때는 경로 설정, 접속 정책, 충돌, 보안 등 문제를 고려해야 하는데, 이를 운영체제가 관리

## 2.3 명령 해석기

- 사용자나 프로그램에서 대화형으로 입력한 명령어를 이해하고 실행하는 사용자와 운영체제의 인터페이스
- 사용자가 입력한 명령은 제어문으로 운영체제에 전달, 이 전달을 명령 해석기가 담당

# 03 운영체제의 발전 과정과 유형

## 1. 운영체제의 발전 과정

|     연도      | 운영체제                                                                          | 특징                                                                                                                                                                                                                                                                                                                                                                                                        |
| :-----------: | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   1940년대    | 운영체제 없음(작업별 순차 처리)                                                   | - 기계어를 직접 사용<br>- 단순 순차(직렬) 처리                                                                                                                                                                                                                                                                                                                                                              |
|   1950년대    | 일괄 처리 시스템                                                                  | - 운영체제의 효시인 IBM 701 개발<br>- 작업별로 일괄 처리<br>- 버퍼링, 스풀링 방법 등장                                                                                                                                                                                                                                                                                                                      |
|   1960년대    | 다중 프로그래밍 시스템<br>시분할 시스템<br>다중 처리 시스템<br>실시간 처리 시스템 | - 가상 기억장치 등장<br>- 다중 프로그래밍, 다중 처리, 시분할 처리 등 개념 등장<br>- 운영체제를 고급언어로 작성<br>- 데이터 통신 지원용 운영체제 사용                                                                                                                                                                                                                                                        |
| 1970년대 초반 | 다중 모드 시스템<br>범용 시스템                                                   | - 일괄 처리, 시분할 처리, 실시간 처리, 다중 프로그래밍 등을 제공하는 다중 모드 시스템 등장<br>- 장치의 독립성 제공<br>- TCP/IP 통신 표준 활성화<br>- 운영체제가 네트워크와 보안을 아우르는 수준으로 발전                                                                                                                                                                                                    |
| 1970년대 중반 | 분산 처리 시스템                                                                  | - 각종 응용 프로그램 개발 및 데이터베이스 활용 확대<br>- 네트워크 기술의 발전<br>- 하드웨어에 운영체제 개념이 포함된 펌웨어 개념 등장                                                                                                                                                                                                                                                                       |
|   1990년대    | 병렬 계산과 분산 계산                                                             | - 월드와이드웹의 등장으로 분산 컴퓨팅 증가<br>- GUI 강화<br>- 개인용과 서버용 운영체제의 보편화                                                                                                                                                                                                                                                                                                             |
| 2000년대 이후 | 모바일 및 임베디드<br>가상화 및 클라우드 컴퓨팅                                   | - 네트워크 기반의 분산 및 병렬 운영체제의 보편화<br>- 모바일 장치와 가전제품을 위한 모바일 및 임베디드 운영체제의 보편화<br>- 다양한 기능, 확장성과 호환성 극대화<br>- 다양한 통신망의 확대와 개발형 시스템 발달<br>- 여러 운영체제가 한 시스템의 자원을 공유할 수 있게 해주는 서버 가상화 기술의 확산<br>- 컴퓨팅 자원, 스토리지, 소프트웨어 등을 사용자에게 서비스 형태로 제공하는 클라우드 컴퓨팅의 등장 |

## 1.1 1940년: 운영체제 없음(작업별 순차 처리)

- 사용자가 기계어로 직접 프로그램을 작성하여 실행하는 작업별 순차 처리 시스템을 사용
- 아직 운영체제 개념은 없음
- 컴퓨터에 필요한 모든 작업을 프로그램에 담음

## 1.2 1950년대: 일괄 처리 시스템

- 초기 운영체제인 일괄 처리 시스템은 작업을 올리는 시간과 해제하는 시간 낭비를 줄이는 데 관심을 둠
- 즉시 처리하지 않고 일정량이 될 때까지 모아 두었다가 한꺼번에 처리하여 작업 준비 시간을 줄임
- **일괄 처리, 버퍼링, 스풀링** 등 방법 도입
- 일괄 처리의 장점
  - 많은 사용자와 프로그램이 컴퓨터 자원을 공유할 수 있음
  - 컴퓨터 자원을 덜 사용 중일 때는 작업 처리 시간을 교대할 수 있음
  - 시시각각 수동으로 개입하고 감독하여 컴퓨터 자원의 유휴를 피할 수 있음

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-6.jpg" alt="그림 2-6 일괄 처리" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-6 일괄 처리<br>

- 일괄 처리의 단점
  - 준비 작업들의 유형이 동일
  - 모든 유형의 입력을 할 수 없음
  - 입출력장치가 프로세서보다 속도가 느려 프로세서가 종종 유휴 상대가 됨
  - 작업의 우선 순위를 주기도 어려움

- 버퍼링
  - 프로세서와 입출력장치의 속도 차이로 생긴 유휴시간이 없도록 입출력장치별로 입출력 버퍼를 둠
  - 프로세서에서 연산을 할 때 동시에 다른 작업을 입출력하는 아주 간단한 방법
  > 프로세서가 어떤 작업을 처리하는 동안 버퍼에 다음으로 처리할 작업을 미리 읽어 저장해 두는 메모리

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-7.jpg" alt="그림 2-7 버퍼링" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-7 버퍼링<br>

- 스풀링
  - 속도가 빠른 디스크를 버퍼처럼 사용하여 입출력장치에서 미리 읽는 것
  - 스풀링은 별개의 오프라인 장치를 사용
  - 여러 작업의 입출력과 계산을 함께 할 수 있음
  - 프로세서에 일정한 디스크 공간과 테이블만 있으면 하나의 계산 작업과 다른 입출력 작업을 중복해서 처리할 수 있음
  
<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-8.jpg" alt="그림 2-8 스풀링" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-8 스풀링<br>

## 1.3 1960년대: 다중 프로그래밍 · 시분할 · 다중 처리 · 실시간 시스템

이 시기 운영체제의 특징은 장치 독립성을 이용한 편리한 하드웨어 관리와 시스템의 처리 능력 향상이다.

- **다중 프로그래밍 시스템**
  - 여러 프로그램을 메모리에 나눠 적재한 후 프로세서를 번갈아 할당하여 프로세서의 사용을 극대화하면서 여러 프로그램을 동시에 실행
- **시분할 시스템**
  - 다중 프로그래밍 시스템에 프로세서 스케줄링이라는 개념을 더한 것
  - 일정한 프로세서 사용 시간을 할당하여 빠른 응답이 가능하므로 사용자와 대화하는 방법으로 여러 프로그램을 실행
- **다중 처리 시스템**
  - 하나의 시스템에서 프로세서를 여러 개 사용하여 처리 능력을 높인 것
- **실시간 처리 시스템**
  - 즉시 응답한다는 특징

> 프로그램을 다른 입출력장치와 함께 실행할 수 있는 것이 장치 독립성의 개념

## 1.4 1970년대 초반: 다중 모드 · 범용 시스템

- 모든 사용자에게 모든 기능을 제공할 수 있도록 범용 시스템으로 설계
- 일괄 처리, 시분할 처리, 실시간 처리, 다중 처리를 모두 제공하는 다중 모드 시스템도 등장
- 하지만, 사용에 고도의 훈련이 필요했음. 컴퓨터가 더욱 복잡해져 사용자가 익숙해 질 때까지 시간이 많이 걸림

## 1.5 1970년대 중반~1990년대: 분산 처리 시스템, 병렬 계산과 분산 계산

- 컴퓨터 네트워크와 온라인 처리 방법을 널리 사용 -> 네트워크를 이용하여 멀리 떨어진 컴퓨터를 사용
- 멀리 떨어진 여러 시스템과 통신할 수 있어 정보 보호가 중요한 관심사
- 분산 처리 개념을 확립하여 컴퓨터가 있는 곳으로 데이터를 가져가 처리하기보다는 데이터가 발생하는 곳으로 컴퓨터의 능력을 가져오는 데 관심

## 1.6 2000년대 이후: 모바일 및 임베디드, 가상화 및 클라우드 컴퓨팅

- 21세기 중요한 변화는 스마트폰이나 태블릿 같은 모바일 기기

- 따라서 모바일 운영체제가 중요

- 모바일 운영체제는 모바일 장치나 정보 기기를 제어하는 운영체제

- 또한, 각종 사물에 컴퓨터 칩과 통신 기능을 내장하여 인터넷에 연결하는 사물인터넷 기술 등장

- 한편, 이시기에는 1960년대 후반 등장한 가상화 기술이 본격적으로 확산
  - 가상화는 물리적 자원을 추상화하여 논리적 자원 형태로 표현하는 기술
  - 적용 대상에 따라 **서버 가상화, 데스크톱 가상화, 스토리지 가상화, 네트워크 가상화, 소프트웨어 가상화**로 구분

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-9.jpg" alt="그림 2-9 서버 가상화의 개념" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-9 서버 가상화의 개념<br>

- 운영체제와 가장 관련된 것은 서버 가상화
  - 물리적 서버 하나에 가상 서버를 여러 개 구성하는 방법
  - 서버 하나에서 각 응용 프로그램과 운영체제를 독립된 환경으로 사용할 수 있어 여러 운영체제가 한 시스템의 자원 공유 가능
  - 서버 가상화 종류
    - 호스트 기반 가상화
      - 호스트 운영체제에서 가상 머신을 구동
      - 설치 쉬움, 구성이 편리
      - 하지만 성능이 떨어질 수 있음
    - 베어메탈 기반 가상화
      - 호스트 운영체제 설치 전에 가상화 솔루션을 탑재하여 가상의 CPU, 메모리, 디스크, 네트워크 카드 등을 생성
      - 향상된 성능을 제공, 실시간 운영체제를 지원
      - 하지만 운영체제 위에 없기 때문에 디바이스용 드라이버, 하드웨어 플랫폼 드라이버 등을 포함해야하고 설치와 구성이 어려움

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-10.jpg" alt="그림 2-10 서버 가상화 종류" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-10 서버 가상화 종류<br>

- 서버 가상화 기술을 이용하여 사용자에게 서비스 형태로 제공하는 클라우드 컴퓨팅이 등장
  - 클라우드 컴퓨팅은 그리드 컴퓨팅, 유틸리티 컴퓨팅, 서버 기반 컴퓨팅의 특징을 조금씩 차용한 개념
  - 이러한 모델은 여러 특징을 보임
    - 클라우드 데이터 센터에서 원하는 만큼 컴퓨터 자원을 무한대로 사용
    - 컴퓨터 자원을 원할 때 원하는 만큼 늘리거나 줄일 수 있음
    - 컴퓨터 자원을 사용한 만큼 사용료 지불
  - 클라우드 컴퓨팅 기술을 이용한 서비스는 크게 **IaaS, PaaS, SaaS**로 분류
    - **IaaS**
      - 데이터 센터에 있는 서버, 스토리지, 네트워크 등 인프라나 자원을 가상화하여 인터넷으로 제공
    - **PaaS**
      - 응용 프로그램의 구축, 테스트 및 설치가 가능한 통합 개발 환경을 웹으로 제공
      - Open API가 이에 해당
    - **SaaS**
      - 특정 소프트웨어를 인터넷으로 제공
      - 해당 소프트웨어와 관련된 데이터를 클라우드에서 관리
      - 사용자는 웹 브라우저로 접속하여 소프트웨어를 사용

## 2. 운영체제의 유형

컴퓨터 시스템의 발전 과정과 용도, 응답시간이나 데이터 입력 방법에 따라 운영체제를 구분할 수 있음

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-11.jpg" alt="그림 2-11 운영체제의 유형" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-11 운영체제의 유형<br>

## 2.1 다중 프로그래밍 시스템

다중 프로그래밍은 프로세서가 유휴 상태일 때 실행 중인 둘 이상의 작업이 프로세서를 전환(인터리빙)하여 사용할 수 있도록 동작

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-12.jpg" alt="그림 2-12 다중 프로그래밍 시스템" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-12 다중 프로그래밍 시스템<br>

위 그림을 보면 작업 2가 프로세서를 사용하다가 입출력 동작 중이면 그동안 작업 1이 프로세서를 사용한다. 작업 3은 프로세서 실행 시간을 얻을 떄까지 대기하도록 하여 프로세서가 쉬지 않게 함으로써 프로세서 사용을 극대화

> 프로세서의 유휴시간에도 다른 프로그램을 처리하여 동시에 여러 프로그램을 실행하는 것과 같은 효과를 내어 프로세서 효율을 극대화

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-13.jpg" alt="그림 2-13 다중 프로그래밍 시스템의 처리 방법 예" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-13 다중 프로그래밍 시스템의 처리 방법 예<br>

- 다중 프로그래밍의 장점은 높고 효율적인 프로세서 사용률(효율적인 운영)이 증가
- 사용자의 프로그램이 거의 동시에 프로세서를 할당받는 듯한 느낌을 줌

## 2.2 시분할 시스템

- 다중 프로그램을 논리적으로 확장한 개념
  - 프로세서가 다중 작업을 교대로 수행
  - 다수의 사용자가 동시에 컴퓨터 자원을 공유할 수 있는 기술

- 프로세서에 적재된 여러 프로그램을 교대로 실행
- 각 프로그램에 일정한 프로세서 사용 시간 또는 규정 시간량을 할당하여 사용자가 주어진 시간 동안 컴퓨터와 대화하는 형식으로 실행
- 여러 사용자에게 짧은 간격으로 프로세서를 번갈아 가며 할당
- 마치 단독으로 프로세서를 독점하고 있는 착각을 불러일으킴
- 여러 사용자가 단일 컴퓨터를 동시에 사용할 수 있게 함

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-14.jpg" alt="그림 2-14 시분할 시스템의 처리 방법 예" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-14 시분할 시스템의 처리 방법 예<br>

- 다중 프로그래밍 시스템과 시분할 시스템은 둘 다 메모리에 여러 프로그램을 적재하므로 메모리를 관리해야 함
- 어떤 프로그램을 먼저 실행할지 결정하는 스케줄링이라는 개념이 필요
- 시분할 시스템은 응답시간을 최소화하는 것이 목표

- 시분할 시스템은 여러 작업을 메모리에 저장하므로 짧은 시간에 작업을 교체할 수 있도록 메모리를 적절하게 관리해야 하고, 한 작업이 다른 작업의 데이터를 변경하는 등 작업 보호가 필요

|       |                                                                                           |
| :---: | :---------------------------------------------------------------------------------------- |
| 장점  | - 빠른 응답 제공<br>- 소프트웨어의 중복 회피 가능<br>- 프로세서 유휴시간 감소             |
| 단점  | - 신뢰성 문제<br>- 보안 의문 및 사용자 프로그램과 데이터의 무결성<br>- 데이터 통신의 문제 |
|       |                                                                                           |

## 2.3 다중 처리 시스템

단일 컴퓨터 시스템 내에서 둘 이상의 프로세서를 사용하여 동시에 둘 이상의 프로세스(프로그램)를 지원

- 여러 프로세서와 시스템 버스, 클록, 메모리와 주변장치 등을 공유
- 빠르고, 프로세서 하나가 고장이 나도 다른 프로세서를 사용하여 작업을 계속할 수 있어 신뢰성이 높음
- 프로세서가 여러 개 이므로 프로세서 간의 연결, 상호작용, 역할 분담 등을 고려해야 함

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-15.jpg" alt="그림 2-15 다중 처리 시스템" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-15 다중 처리 시스템<br>

## 2.4 실시간 처리 시스템

실시간 처리 시스템은 데이터 처리 시스템으로 정의하고 입력에 응답하는 데 필요한 시간 간격이 너무 짧아서 환경을 제어

- 실시간 처리 시스템은 항상 온라인 상태이어야 함
- 입력 및 업데이트된 정보 요구를 처리한 후 디스플레이에 응답하는 시스템에 소요되는 시간을 반응(응답)시간이라함
- 반응시간은 프로세서에 이미 고정

- 해당 시스템은 더 높은 적시 응답을 요구하는 장소에서 사용하거나 데이터 흐름 또는 프로세서 연산에 엄격한 시간 요구가 있을 때 사용할 수 있음
- 실시간 처리 시스템은 다음 두 유형으로 분류
  - **경성 실시간 처리 시스템**
    - 작업의 실행 시작이나 완료에 대한 시간 제약 조건을 지키지 못할 때 시스템에 치명적인 영향을 주는 시스템
      - ex) 무기제어, 발전소 제어, 철도 자동 제어, 미사일 자동 조준
    - 보장되는 컴퓨팅, 시간의 정확성과 컴퓨팅 예측성을 갖게 해야 함
  - **연성 실시간 처리 시스템**
    - 작업 실행에서 시간 제약 조건을 지키지 못해도 전체 시스템에 치명적인 영향을 미치지 않는 시스템
      - ex) 동영상 플레이어 재생 -> 여러 프레임을 넘겨도 괜찮음

## 2.5 분산 처리 시스템

시스템마다 독립적인 운영체제와 메모리로 운영하며, 필요할 때 통신하는 시스템

- 분산 처리 시스템은 사용자에게는 중앙집중식 시스템처럼 보이는데, 다수의 독립된 프로세서에서 실행
- 데이텋를 여러 위치에서 처리 · 저장
- 여러 사용자가 공유할 수 있음
- 하나의 프로그램을 여러 프로세서에서 동시에 실행할 수도 있음

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-16.jpg" alt="그림 2-16 분산 처리 시스템" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-16 분산 처리 시스템<br>

# 04 운영 체제의 서비스

운영체제가 어떤 서비스를 제공하여 기능을 수행하는지 알아야한다. 보통은 다음 네 가지로 제공한다.

- 부팅 서비스: 컴퓨터 하드웨어를 관리하고 프로그램을 실행할 수 있도록 컴퓨터에 시동을 건다.
- 사용자 서비스: 프로그래머가 프로그래밍 작업을 쉽게 수행할 수 있도록 한다.
- 시스템 서비스: 시스템의 효율적인 동작을 보장한다.
- 시스템 호출: 프로그램이 운영체제의 기능을 서비스받을 수 있는 프로그램과 운영체제 간의 인터페이스를 제공한다.

## 1. 부팅 서비스

- 운영체제를 메인 메모리에 적재하는 과정을 부팅 또는 부트스트래핑이라고 함
  - 부트로더
    - 부트스트랩 로더를 줄인 말로, 하드디스크와 같은 보조기억장치에 저장된 운영체제를 메인 메모리에 적재하는 ROM에 고정시킨 소규모 프로그램

- 초기화
  - 초기 운영체제는 하드웨어를 초기화하지 않고 컴퓨터를 작동
  - 메모리의 효율적인 활용 등에 관심을 가지면서 전체적인 초기화뿐만 아닌 일시적인 하드웨어 오류로 활동중인 작업이 손실되지 않도록 복구하거나 회복하는 방법과 비정상적인 작업을 처리하는 부분적인 초기화가 포함됨
  - 목적으로는 시스템 장치 초기화, 시간 설정, 명령 해석기 적재와 준비가 있음
    - 시스템 장치의 초기화는 디렉터리, 파일 등을 점검하고, 시스템 버퍼와 인터럽트 벡터를 초기화
    - 운영체제의 루틴 대부분을 메모리 하위 주소에 적재하도록 설정

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-17.jpg" alt="그림 2-17 부팅 과정" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-17 부팅 과정<br>

## 2. 사용자 서비스

프로그래머가 프로그래밍 작업을 쉽게 수행할 수 있도록 다음 사용자 서비스를 제공

## 2.1 사용자 인터페이스 제공

사용자 인터페이스는 사용자와 컴퓨터 간의 상호작용이 발생하는 공간으로 CLI, 메뉴, GUI 등 형태로 구현

- CLI(Command Line Interface, 명령 라인 인터페이스)
  >CLI는 사용자가 키보드 등으로 명령어를 입력하여 시스템에서 응답을 받을 후, 또 다른 명령어를 입력하여 시스템을 동작하게 하는 텍스트 전용 인터페이스
  - 사용자가 프롬프트에서 명령어를 입력하여 컴퓨터와 상호작용
- 메뉴 인터페이스 
  >메뉴 등을 사용하여 시스템과 상호작용한다.
  - 사용이 편리하며, 배우거나 기억해야할 명령이 없음
  - ex) 휴대폰, 현금 자동 인출기

- GUI(Graphical User Intgerface, 그래픽 사용자 인터페이스)
  >GUI는 윈도우 환경에서 사용자에게 정보와 작업을 표현하는 텍스트, 레이블이나 텍스트 탐색과 함께 그래픽 아이콘과 시각적 표시기, 버튼이나 스크롤바와 같은 위젯 그래픽 제어 요소를 사용하여 컴퓨터와 상호작용할 수 있는 가장 보편적인 유형

## 2.2 프로그램 실행

- 프로그램을 실행하려면 먼저 메모리에 적재해야 하고, 프로세서 시간을 할당해야함
- 운영체제는 프로그램을 실행하려고 메모리 할당이나 해제, 프로세서 스케줄링과 같은 중요 작업을 처리

## 2.3 입출력 동작 수행

- 수행 중인 프로그램은 입력이 필요
- 사용자가 제공하는 입력을 처리한 후에는 출력을 생성해야 함
- 운영체제는 입출력 동작을 직접 수행할 수 없는 사용자 프로그램의 입출력 동작 방법을 제공

## 2.4 파일 시스템 조작

- 사용자는 디스크에서 파일을 열고, 저장, 삭제하는 등 다양하게 파일을 조작함
- 운영체제는 파일 시스템 조작 서비스를 제공하여 사용자가 이런 파일 관련 작업을 쉽게 할 수 있도록 함

## 2.5 통신(네트워크)

- 프로세스가 다른 프로세스와 정보를 교환하는 방법
  - 첫 번쨰, 동일한 컴퓨터에서 수행하는 프로세스 간의 정보 교환
  - 두 번째, 네트워크로 연결된 컴퓨터 시스템에서 수행하는 프로세스 간의 정보 교환

- 운영체제는 다중 작업 환경에서 공유 메모리를 이용하거나 메시지 전달로 다양한 유형의 프로세스와 통신을 지원

## 2.6 오류 탐지

- 가능한 모든 하드웨어와 소프트웨어 수준에서 오류를 탐지
- 시스템을 모니터링하여 조정함으로써 하드웨어 문제를 예방
- 오류를 감지한 후 유형별로 적절히 조치
  - 프로세서, 메모리 하드웨어와 관련된 오류: 기억장치 메모리 오류, 정전
  - 입출력장치 오류: 패리티 오류, 카드 판독기의 카드 체증, 프린터의 종이 부족
  - 사용자 프로그램 오류: 연산의 오버플로, 부적당한 기억장치 장소 접근, 프로세서 시간을 지나치게 많이 사용

## 3. 시스템 서비스

사용자가 아닌 시스템 자체의 효율적인 동작을 보장하는 기능
여러 사용자가 사용하는 시스템에서는 컴퓨터 자원을 공유하여 시스템 자체의 효율성을 높일 수 있음

## 3.1 자원 할당

다수의 사용자나 작업을 동시에 실행할 때는 운영체제가 자원을 각각 할당하도록 관리

## 3.2 계정

각 사용자가 어떤 컴퓨터 자원을 얼마나 많이 사용하는지 정보를 저장하고 추적

## 3.3 보호와 보안
>**보호**는 시스템 호출을 하려고 전달한 모든 매개변수의 타당성을 검사하고, 시스템 자원에 모든 사용자 접근을 제어하도록 보장<br>
**보안**은 잘못된 접근 시도에서 외부 입출력장치를 방어하며, 외부에 사용자 인증을 요구

다중 사용자 컴퓨터 시스템에 저장된 정보 소유자의 사용을 제한할 수 있음

- 서로 관련이 없는 여러 작업을 동시에 수행할 때는 한 작업이 다른 작업이나 운영체제를 방해하지 못하게 해야함

## 4.시스템 호출

- 실행 중인 프로그램과 운영체제 간의 인터페이스로 API라고도 함
- 사용자 프로그램은 시스템 호출을 하여 운영체제의 기능을 제공받음
- 시스템과 상호작용하는 동작은 대개 사용자 수준 프로세서에서는 사용할 수 없으나, 시스템 호출을 하여 운영체제에 서비스를 요청
- 시스템 호출 방법
  - 첫 번째, 프로그램에서 명령이나 서브루틴의 호출 형태로 호출하는 방법, 보통은 어셈블리어로 제공, 고급 언어(C, C++)로 작성한 프로그램에서 직접 수행
  - 두 번째, 시스템에서 명령 해석기를 사용하여 대화 형태로 호출하는 방법

|  호출 서비스  | 설명                                                                                                                                                 |
| :-----------: | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| 프로세스 제어 | - 종료와 취소<br>- 적재와 실행<br>- 프로세스 생성과 종료<br>- 프로세스 속성 획득과 지정<br>- 대기와 대기 이벤트, 신호 이벤트<br>- 메모리 할당과 해제 |
|   파일 조작   | - 파일 생성과 삭제<br>- 파일 열기와 닫기<br>- 파일 읽기와 쓰기, 파일 재배치<br>- 파일 속성 획득과 지정                                               |
|   장치조작    | - 장치 요구와 해제<br>- 장치 읽기와 쓰기, 재배치<br>- 장치 속성 획득과 설정<br>- 논리적 부착이나 장치 제거                                           |
|   정보 관리   | - 시간과 날짜의 설정과 획득<br>- 데이터의 설정과 획득<br>- 프로세스, 파일, 장치 속성의 설정과 획득                                                   |
|     통신      | - 통신 연결의 생성과 제거<br>- 메시지의 송수신<br>- 정보 상태 전달<br>- 원격 장치의 부착 및 제거                                                     |
|               |                                                                                                                                                      |

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-18.jpg" alt="그림 2-18 시스템 호출 예" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-18 시스템 호출 예<br>

# 05 운영체제의 구조

운영체제가 점점 더 다양한 하드웨어와 소프트웨어를 지원하면서 구조 또한 복잡해짐
복잡한 시스템은 설계, 구현, 테스트, 유지 보수 등 면에서 쉽지 않아 이를 해결하려고 운영체제를 설계하는 다양한 방법이 등장

## 1. 단일 구조 운영체제

- 단일 구조 운영체제는 초기에 생겨난 가장 보편적인 형태
- 운영체제의 모든 기능을 커널과 동일한 메모리 공간에 적재한 후 시스템 호출만으로 사용
- 작고 간단하면서 시스템 기능이 제한된 구조
- 대다수 기능을 최소한의 영역으로 제공
- 한 계층으로는 결합할 수 없는 많은 기능으로 구성
- ex) 초기 유닉스

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-19.jpg" alt="그림 2-19 단일 구조 운영체제 예 1 : 도스" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-19 단일 구조 운영체제 예 1 : 도스<br>

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-20.jpg" alt="그림 2-20 단일 구조 운영체제 예 2 : 초기 유닉스" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-20 단일 구조 운영체제 예 2 : 초기 유닉스<br>

- 커널에는 파일 시스템, 프로세서 스케줄링, 메모리 관리 등이 포함
- 시스템 호출을 하여 또 따른 운영체제 기능을 제공

- 단일 구조 운영체제는 대부분의 기능을 커널에 그룹화해서 구현
- 직접 통신하여 시스템 자원을 효율적으로 관리하는 장점이 있음
- 그러나 커널 크기가 상대적으로 커지면서 버그의 원인이나 오류를 구분하기 어려움
- 새 기능을 추가하는 수정과 유지 보수가 어려움
- 또한 동일한 메모리에서 실행하므로 한 부분에서 발생한 문제 때문에 시스템 전체에 심각한 영향을 줄 수 있음

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-21.jpg" alt="그림 2-21 단일 커널 구조" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-21 단일 커널 구조<br>

## 2. 계층 구조 운영체제

- 계층 구조에서는 비슷한 기능을 수행하는 요소를 그룹화하여 계층적으로 구성
  - 최하위 계층(계층 0)인 하드웨어에서 최상위 계층(계층 5)인 사용자 인터페이스까지 다수의 계층(수준)으로 구성
  - 각 계층은 인접한 상위나 하위에 있는 계층과 상호작용
- 해당 구조는 사용자 프로세스의 요청을 수행할 때 여러 계층을 거쳐야 하므로, 한 계층에서 다음 계층으로 데이터를 전달할 때마다 추가적인 시스템 호출이 발생
- 단일 구조보다는 성능이 떨어짐
- 계층적 구조의 장점은 모듈화로 단일 구조 운영체제보다 모듈화가 잘 되어있음
- 각 계층은 자신의 하위 계층 서비스와 기능만 사용
  - 따라서, 계층 구조에서는 시스템 검증과 오류 수정을 쉽게 할 수 있음
- 특정 계층에서 오류를 발견하더라도 하위 계층은 오류를 수정했기 때문에 해당 계층에 오류가 없음
- 시스템을 계층으로 나누면 시스템 설계나 구현이 단순
- 그러나 계층 구조 운영체제에서는 계층을 정의하기 어려움
  - 각 계층은 자신의 하위 계층만 사용 가능하므로 신중히 설계해야함

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-22.jpg" alt="그림 2-22 계층 구조 운영체제 예 : THE 운영체제" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-22 계층 구조 운영체제 예 : THE 운영체제<br>

## 3. 마이크로 커널 구조 운영체제

>마이크로 커널은 커널의 기능을 많이 제외시키고 최소 기능만 포함시켜 크기를 대폭 줄이고 기타 기능은 사용자 공간으로 옮겨 사용자 영역에서 수행하는 서버 구현 방법

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter2\그림 2-23.jpg" alt="그림 2-23 마이크로 커널 구조 예" style="border:1px; border-style: solid; zoom:100%;"/>

그림 2-23 마이크로 커널 구조 예<br>

- 운영체제 서비스를 사용자 영역의 독립적인 서버에서 수행하기 때문에 서버에서 잘못 수행하더라도 다른 서버와 커널에 치명적인 영향을 주지 않음
- 사용자 영역의 서버에서 운영체제의 많은 기능을 구현가능해 개발이 용이하고 운영체제의 기능을 쉽게 변경
- 모듈화 정도가 높아 확장성, 이식성, 규모 확장성이 높지만 모듈 간에 통신이 빈번하게 발생
  - 성능이 떨어질 수 있으니 프로세스 간 통신 발생을 최소화시키는 것이 중요