# Chapter 03 프로세스와 스레드

# 01 프로세스의 개념과 상태 변화

## 1. 프로세스의 개념

- 컴퓨터의 효율을 높이는 방법
    - 프로그램 병행 실행
    - 병행 실행하는 프로그램들이 자원을 공유할 수 있는 방법 제공
    

위 방법을 수행하기 위해 프로세스가 등장 

- 프로세스(작업, task)
    - 정의
        - 실행 중인 프로그램 - 디스크에 있던 프로그램을 메모리에 적재하여 운영체제의 제어를 받는 상태
    - 예) 웹 브라우저 창을 한 개 열면 → 프로세스 한 개, 두 개 열면 → 프로세스 두 개
    - 프로세스가 실행 중인 프로그램이 되기 위해 필요한 자원으로 프로세스 생성시 해당 자원 할당
        - 프로세서 점유 시간
        - 메모리
        - 파일
        - 입출력장치 등
    - 현재 활동 상태를 나타내는 프로그램 카운터, 프로세서의 현재 활동(레지스터 내용)도 포함

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-1.jpg" alt="그림 3-1" style="border:1px; border-style: solid; zoom:100%;"/>

- 프로그램과 프로세스 차이
    - 프로그램
        - 컴파일한 코드와 초기화 전역변수
        - 문자열과 문자열 상수 등 정적 데이터를 포함
        - 정적인 개체
    - 프로세스
        - 메모리 구조
        - 프로그램 카운터나 레지스터
            - 현재 어떤 자원을 사용하는 지 관련 정보가 들어있음
        - 동적인 개체
        

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-2.jpg" alt="그림 3-2" style="border:1px; border-style: solid; zoom:100%;"/>

- 스택(stack)
    - 데이터를 일시적으로 저장하는 영역
    - 지역변수에 사용
    - 변수가 범위 밖으로 이동하면 공간을 해제
    
- 힙(heap)
    - 코드 영역과는 별도로 유지되는 자유영역
    - 동적으로 메모리를 할당
        - 프로그램 실행 중 시스템 호출을 사용했다가 해제하는 방법 활용
        
- 데이터
    - 프로그램의 가상 주소 공간
    - 전역변수나 정적변수를 저장 및 할당하고 실행하기 전에 초기화
    
- 코드
    - 실행 명령을 포함하는 메모리
    - 목적 파일에 있는 프로그램 영역
    - 프로그램 시작 시, 프로세서가 디스크에서 읽어 실행하는 컴파일한 프로그램을 저장
    

스택과 힙 사이는 서브루틴을 실행하는 영역으로 운영체제로 매핑되지 않음

데이터베이스, 문서 편집기처럼 여러 사용자가 메모리에 있는 동일한 사본을 공유할 수 있는 프로그램을 **재진입 프로그램** 이라고 함

이들은 실행 중 사용할 데이터를 보관하는 스택 영역과 공통 데이터를 보관하는 데이터 영역으로 나뉨

프로세스 2개가 동일한 문서 편집기를 사용하고 데이터 영역이 같더라고 스택 영역은 서로 달라 별개의 프로세스로 인식

- 사용자 관점과 시스템 관점에서의 프로세스
    - 사용자 관점
        - 주소 공간을 가지고 실행하는 프로그램
    - 시스템 관점
        - 실행 중인 프로그램
    - 실행 순서를 결정하는 스케줄러는 디스크에 저장된 프로그램에 프로세서를 할당해서 장치나 메모리 같은 파일 자원을 참조

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-3.jpg" alt="그림 3-3" style="border:1px; border-style: solid; zoom:100%;"/>

- 프로세스가 수행하는 역할
    - 이에 따라 시스템(커널) 프로세스와 사용자 프로세스로 구분
    - 또, 병행 수행 방법에 따라 독립 프로세스와 협력 프로세스로 구분

<br>

| 구분 | 종류 | 설명 |
| :------: | ------ | ------ |
| 역할 | 시스템(커널) 프로세스 | 모든 시스템 메모리와 프로세서의 명령에 액세스할 수 있는 프로세스 |
| 역할 | 사용자 프로세스 | 사용자 코드를 수행하는 프로세스 |
| 병행 수행 방법 | 독립 프로세스 | 다른 프로세스에 영향을 주지않거나 다른 프로세스의 영향을 받지 않으면서 수행하는 병행 프로세스 |
| 병행 수행 방법 | 협력 프로세스 | 다른 프로세스에 영향을 주거나 다른 프로세스에서 영향을 받는 병행 프로세스 |

<br>

## 2. 프로세스의 상태 변화와 상태 정보

운영체제는 프로세스의 실행을 제어

프로세스는 실행하면서 상태가 변함

운영체제는 프로세스 제어에 필요한 상태를 점검하고 프로세스를 제어

### 2.1. 프로세스의 상태 변화

- 프로세스의 상태
    - 크게 실행 상태와 비실행 상태로 구분
    - 운영체제가 프로세스를 생성하면 비실행 상태로 초기화해서 실행 기다림
    - 실행 중인 프로세스의 종료 및 인터럽트 발생 시
        - 비실행 프로세스 중 선택한 프로세스를 실행상태로 변경(디스패치)
        - 인터럽트된 프로세스는 비실행 상태

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-4.jpg" alt="그림 3-4" style="border:1px; border-style: solid; zoom:100%;"/>

    - 프로세스의 상태는 준비, 실행, 대기(보류)로 더 세분화 가능
        - 어느 한순간 프로세스가 준비나 대기 상태로 바뀌면서 하나만 실행 상태가 된다는 점 중요
    - 프로세스는 시스템에서 준비, 실행, 대기 상태로 바뀌면서 실행하고 종료
        - 시스템을 떠날 때까지 이 과정을 반복

    - 프로세스의 상태 변화는 운영체제가 프로세서 스케줄러를 이용하여 관리
        - 작업 스케줄러
            - 스풀러가 디스크에 저장한 작업 중 실행할 작업을 선정
            - 준비 리스트에 삽입하여 다중 프로그래밍의 정도를 결정
        - 프로세스 스케줄러
            - 선정한 작업의 상태를 변화
            - 프로세스의 생성에서 종료까지 과정을 수행
            
<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-5.jpg" alt="그림 3-5" style="border:1px; border-style: solid; zoom:100%;"/>

    - 실행 상태의 프로세스가 프로세서를 자발적으로 반환하기 전에 할당된 시간이 지나면 이 프로세스는 준비 상태가 됨
    - 프로세스를 실행하다 입출력 명령이 발생하면 대기 상태가 됨
        - 대기 상태 프로세스는 대기 원인을 제거하면 준비 상태로 변경
    - 디스패처(dispatcher)가 준비 상태인 프로세스에 프로세서를 할당하면 다시 실행 상태
        - 디스패처는 스케줄러가 선택한 프로세스에 프로세서를 할당하는 모듈
        
<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-6.jpg" alt="그림 3-6" style="border:1px; border-style: solid; zoom:100%;"/>
        
- 프로세스의 상태별 변화
    - 프로세스 스스로 하는 것은 대기 뿐
    - 나머지는 외부 조건으로 발생

<br>

| 상태 변화 | 표기 방법 |
| :------: | ------ |
| 준비 -> 실행 | dispatch(프로세스 이름) |
| 실행 -> 준비 | timeout(프로세스 이름) |
| 실행 -> 대기 | block(프로세스 이름) |
| 대기(보류) -> 준비 | wakeup(프로세스 이름) |

<br>
    

- 준비 → 실행
    - 준비 큐 맨 앞에 있던 프로세스가 프로세서를 점유하는 것을 디스패치하고 함
- 실행 → 준비
    - 운영체제는 실행 상태의 프로세스가 프로세서를 계속 독점하지 않도록 인터럽트 클록(interrupt clock)을 두어 특정 프로세스가 할당된 시간 동안만 프로세서를 점유하게 함
- 실행 → 대기(보류)
    - 할당된 시간 이전에 실행 상태의 프로세스에 입출력 연산 등이 필요하거나 새로운 자원 요청 등의 문제로 프로세서를 스스로 양도하면 대기 상태가 됨
- 대기(보류) → 준비
    - 프로세스는 입출력 작업이 끝나면 깨움(wake up)으로 대기에서 준비 상태가 됨
    

### 2.2. 프로세스 제어 블록

운영체제가 프로세스를 제어할 때 필요한 프로세스 상태 정보는 프로세스 제어 블록에 저장

- 프로세스 제어 블록(PCB, Process Control Block)
    - 특정 프로세스 정보를 저장하는 데이터 블록이나 레코드
    - 프로세스가 생성되면 메모리에 프로세스 제어 블록을 생성
    - 프로세스가 실행을 종료하면 해당 프로세스 제어 블록도 삭제
    - 프로세스 제어 블록에는 아래와 같은 정보가 들어 있음
        - 운영체제의 모든 모듈이 이 정보를 읽고 수정 가능
        
    
<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-7.jpg" alt="그림 3-7" style="border:1px; border-style: solid; zoom:100%;"/>
    

### 2.3. 프로세스의 문맥 교환

인터럽트나 시스템 호출 등으로 실행 중인 프로세스의 제어를 다른 프로세스에 넘겨 실행 상태가 되도록 하는 것을 프로세스 문맥 교환이라고 함

- 프로세스 문맥 교환이 일어나면 프로세서의 레지스터에 있던 내용을 나중에 사용할 수 있도록 저장

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-8.jpg" alt="그림 3-8" style="border:1px; border-style: solid; zoom:100%;"/>

# 02 프로세스의 관리

## 1. 프로세스의 구조

- 운영체제가 프로세스에서의 작업 수행 가능한 것들
    - 생성, 종료, 제거, 중단(서스펜드 suspend), 재시작, 우선순위 변경, 대기, 문맥 교환 등
- 프로세스가 실행 중 가능한 것
    - 프로세스 생성 시스템 호출을 이용하여 새로운 프로세스를 생성
    - 프로세스 생성 순서를 저장하고 부모-자식 관계를 유지하여 계층적으로 생성
        - 부모 프로세스: 프로세스를 새로 생성하는 프로세스
        - 자식 프로세스 & 서브 프로세스: 생성되는 프로세스
- 부모 프로세스는 자식 프로세스를 생성하는 과정을 반복하며 계층 구조 형성

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-9.jpg" alt="그림 3-9" style="border:1px; border-style: solid; zoom:100%;"/>

## 2. 프로세스의 생성

운영체제나 응용 프로그램에서 요청을 받아 프로세스를 생성하면, 운영체제는 해당 프로세스에서 프로세스 제어 블록을 만들어 주소 공간을 할당

- 프로세스를 생성할 때 필요한 단계별 세부 작업
    
    1) 새로운 프로세스에 프로세스 식별자를 할당
    
    2) 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 프로세스 제어 블록 공간을 할당
    
    3) 프로세스 제어 블록을 초기화. 프로세스 상태, 프로그램 카운터 등 초기화, 자원 요청, 프로세스 제어 정보(우선순위) 등을 포함
    
    4) 링크를 건다(해당 큐에 삽입)
    
- 프로세스가 작업을 수행하기 위한 필요 자원
    - 프로세서 점유 시간, 메모리, 파일, 입출력장치 등
        - 자식 프로세스는 운영체제에서 직접 필요한 자원을 얻거나 부모 프로세스의 자원을 일부 사용할 수 있음

- 이런 자원 외에도 일부 초기화 데이터를 부모 프로세스에서 자식 프로세스로 전달
    - 예) p1 프로세스를 생성하면 부모 프로세스에서 이름이 P인 파일을 입력받아 필요한 정보를 얻고 출력장치의 기능도 전달받을 수 있음

- 프로그램 실행 시 발생가능한 상황
    - 부모 프로세스와 자식 프로세스를 동시에 실행
    - 부모 프로세스는 자식 프로세를 모두 종료할 때까지 기다림
    
- fork 명령어
    - 사용하는 경우는 크게 두 가지
        - 첫 번째, 부모와 동일한 자식을 복제
        - 두 번째, fork 명령어를 호출한 후 exec 명령어를 연달아 호출하여 자식 프로세스의 주소 공간을 별도 프로그램 주소 공간으로 덮어쓰는 것
        

## 3. 프로세스의 종료

프로세스가 마지막 명령을 실행하면 종료하여 운영체제에 프로세스의 삭제를 요청

- 일괄 처리 환경
    - 작업 종료를 의미하는 신호로 인터럽트를 발생
    - 시스템 호출로 중단 명령을 전달하여 프로세스 종료

- 대화형 환경
    - 사용자가 로그로프
    - 터미널을 닫으면 프로세스 종료

- abort 명령어
    - 종료할 프로세스의 부모 프로세스만 호출
    - 자식 프로세스를 종료할 때 자신의 식별자를 부모 프로세스에 전달
    
- 연속 종료
    - 부모 프로세스를 종료하면 자식 프로세스도 필요치 않음. 운영체제가 자식도 종료한다는 것을 의미
        - 자식 프로세스가 할당된 자원을 초과하여 자원을 사용할 때
        - 자식 프로세스에 할당한 작업이 더는 없을 때
        
- 유닉스에서의 종료
    - exit 명령어로 프로세스 종료
    - 부모 프로세스는 wait 명령어를 사용하여 자식 프로세스의 종료를 기다림
    - 프로세스는 다양한 이유로 종료 가능
        - 정상종료: 프로세스가 운영체제의 서비스를 호출할 때
        - 시간 초과: 프로세스가 명시된 전체 시간을 초과하여 실행하거나 명시된 시간을 초과하면서 어떤 이벤트 발생을 기다릴 때
        - 실패: 파일 검색 실패, 입출력이 명시된 횟수를 초과하여 실패할 떄
        - 산술오류, 보호 오류, 데이터 오류 등
        - 메모리 부족, 액세스 위반 등
        

## 4. 프로세스의 제거

프로세스를 파괴하는 것을 의미

- 프로세스를 제거하면 사용하던 자원을 시스템에 돌려줌
- 프로세스는 시스템 리스트나 테이블에서 사라져 프로세스 제어 블록을 회수

## 5. 프로세스의 중단과 재시작

- 프로세스의 준비, 실행, 대기 상태만 이용하면 입출력 동작이 일반 연산보다 느려 시스템이 대부분 유휴 상태

- 시스템의 유휴시간 문제
    - 이것은 프로세스 중단(일시정지) 상태를 이용하여 해결할 수 있음
    - 실행 중인 프로세스를 중단했다가 다시 실행하여 사용할 수 있음
        - 시스템 전체의 부하를 증가시키지 않으면서 프로세스에 서비스를 제공할 수 있음
    - 실행에서 대기가 아닌 중단 상태를 추가하면 특정 이벤트의 발생을 기다리면서 대기 상태가 됨
        - 이벤트가 발생할 때 즉시 실행 상태로 바꿀 수 있음
    

프로세스를 중단한 원인을 제거하여 다시 실행하는 것을 재시작이라고 함

- 프로세스 중단과 재시작은 시스템 부하를 조절하는 데 상당히 중요
- 주로 발생하는 상황
    - 시스템에 장애가 발생하면 실행 중인 프로세스는 잠시 중단했다가 시스템이 기능을 회복할 때 다시 재시작할 수 있음
    - 프로세스에 의심스러운 부분이 있으면 실행 중인 프로세스를 중단하여 확인한 후 재시작하거나 종료
    - 처리할 작업이 너무 많아 시스템에 부담이 되면 프로세스 몇 개를 중단했다가 시스템이 정상 상태로 다시 돌아왔을 때 재시작 할수 있음
    
- 다중 프로그래밍 환경
    - 대다수 시스템은 프로세스 실행 전에 자원을 할당받고 실행
    - 이 환경에서는 자원을 동적으로 할당
        - 자원의 이용률과 시스템 효율을 높임
    - 자원을 할당받으려고 기다리는 상태가 '대기'
    - 할당받은 자원을 기다리는 상태가 '중단'
    

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-10.jpg" alt="그림 3-10" style="border:1px; border-style: solid; zoom:100%;"/>

- 위 그림은 프로세스에 중단된 준비 상태와 중단된 대기 상태를 추가하여 상태가 변화된 모습
- 중단은 프로세스 자신이나 다른 프로세스로 가능
- 중단된 프로세스는 다른 프로세서가 재시작하기 전에는 실행 불가

## 6. 프로세스 우선 순위 변경

프로세스 스케줄러는 프로세스 제어 블록에 있는 우선순위를 이용하여 준비 리스트의 프로세스를 처리

- 준비 리스트의 프로세스
    - 프로세서 중심 프로세스
        - 프로세서를 길게 사용하되 사용 횟수를 줄여서 균형을 유지
    - 입출력 중심 프로세스
        - 속도가 느리면서 빠른 응답을 요구하는 단말기 입출력 프로세스에 높은 우선순위 부여
            - 시간을 적게 할당
        - 속도가 빠른 디스크 입출력 프로세스에는 낮은 우선순위
            - 시간을 많이 할당
            

## 7. 프로세스의 문맥 교환

현재 실행하는 프로세스와 별도로 외부에서 이벤트(예 : 입출력 동작의 종료)가 일어나면 인터럽트가 발생

- 인터럽트 유형에 따라 관련 루틴으로 분기
    - 입출력 인터럽트
        - 입출력 동작 발생 확인
        - 이벤트를 기다리는 프로세스를 준비 상태로 바꾼 후 실행할 프로세스를 결정
    - 클록 인터럽트
        - 현재 실행 중인 프로세스의 할당 시간을 조사하여 실행 중인 프로세스를 준비 상태로 바꿈
        - 다른 프로세스를 실행 상태로 바꿈
        

실행 중인 프로세스에 인터럽트가 발생하면 운영체제가 다른 프로세스를 실행 상태로 바꾸고 제어를 넘겨주어 아래 그림처럼 프로세스 문맥 교환이 일어남

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-11.jpg" alt="그림 3-11" style="border:1px; border-style: solid; zoom:100%;"/>

- 문맥 교환
    - 이전 프로세스의 상태 레지스터 내용을 보관
    - 다른 프로세스의 레지스터를 적재히여 프로세스를 교환
    - 문맥 교환에서는 오버헤드가 발생
    - 문맥 교환 발생
        - '준비' → '실행'
        - '실행' → '준비'
        - '실행' → '대기'
        
    - 문맥 교환은 시간 비용이 들어가는 오버헤드
        - 오버헤드는 메모리 속도, 레지스터 수, 특수 명령어의 유무에 따라 시스템마다 다름
    - 레지스터 문맥 교환, 작업 문맥 교환, 스레드 문맥 교환, 프로세스 문맥 교환이 가능
    - 주요 관심사는 가능한 한 불필요한 문맥 교환을 줄이는 것
    - 스레드를 이용해서 효율적으로 처리할 수 있음
    

# 03 스레드의 개념과 상태 변화

## 1. 스레드의 개념

- 프로세스는 두 가지 특성인 자원과 제어로 구분
- 제어만 분리한 실행 단위를 스레드(thread)
- 프로세스 하나는 스레드 한 개 이상으로 나눌 수 있음
- 시레드들은 프로세스의 직접 실행 정보를 제외한 나머지 프로세스 관리 정보를 공유
- 공유
    - 프로그램 카운터(PC), 스택 포인터(SP), 스레드 실행 환경 정보(문맥 정보), 지역 데이터, 코드, 전역 데이터, 힙

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-12.jpg" alt="그림 3-12" style="border:1px; border-style: solid; zoom:100%;"/>

- 스레드는 다른 프로시저를 호출하고 다른 실행을 기록
    - 별도의 스택 필요
- 프로그램 카운터가 독립적
    - 같은 프로세스의 스레드들이 동시에 코드의 동일한 부분이나 다른 부분을 실행할 수 있음
- 스레드는 관련 자원과 함께 메모리를 공유
- 스레드 중에서 프로세스의 속성 중 일부가 들어 있는 것을 경량 프로세스
- 스레드 하나에 프로세스 하나인 전통적인 경우는 중량 프로세스

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-13.jpg" alt="그림 3-13" style="border:1px; border-style: solid; zoom:100%;"/>

- 한 프로세스에 여러 스레드들은 공동의 목적으로 병렬로 수행
    - 즉, 프로그램의 다른 부분을 동시에 실행할 수 있음
- 스레드 이용 이점
    - 사용자 응답성 증가
        - 응용 프로그램의 일부분을 봉쇄하거나 긴 작업을 수행하더라도 병렬 프로그래밍으로 프로그램을 계속 실행할 수 있음
    - 프로세스의 자원과 메모리 공유 가능
        - 스레드들이 프로세스 자원 하나와 메모리를 공유
        - 응용 프로그램 하나가 동일한 주소 공간에서 스레드를 여러 개 실행하여 시스템 성능을 향상
    - 경제성이 좋음
        - 프로세스를 생성하는 것보다 스레드르 생성하여 문맥을 교환하면 오버헤드가 줄어듦
    - 다중 처리(멀티 프로세싱)로 성능과 효율 향상
        - 각 스레드를 여러 프로세서에서 병렬로 실행하여 성능과 효율성을 높일 수 있음
        

## 2. 단일 스레드와 다중(멀티) 스레드

스레드와 프로세스의 관계는 아래 그림과 같음

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-14.jpg" alt="그림 3-14" style="border:1px; border-style: solid; zoom:100%;"/>

- 단일 스레드를 지원하는 운영체제는 프로세스 하나에 스레드 한 개를 실행하는 전통적인 방법
- 예) 도스

- 다중 스레드
    - 현대 운영체제는 대부분 다중 스레드
    - 프로그램 하나를 여러 실행 단위로 쪼개어 실행한다는 측면
    - 동일 프로세스의 스레드는 자원을 공유
        - 자원 생성과 관리의 중복성을 최소화하여 실행 능력을 향상
    - 각 스레드는 커널이 개입하지 않음
        - 독립적으로 실행
        - 서버에서 많은 요청을 효과적으로 처리
        

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-15.jpg" alt="그림 3-15" style="border:1px; border-style: solid; zoom:100%;"/>

- 위 그림을 보면 모든 스레드가 프로세스의 자원을 공유
- 같은 주소 공간에 있어 동일한 데이터에 접근
- 스레드 한 개가 전역 데이터를 변경하면 다른 스레드도 이 데이터에 접근하여 변경 결과를 확인
- 스레드 한 개가 읽기 권한으로 힙에 있는 파일을 열면 동일한 프로세스의 다른 스레드도 이 파일을 읽을 수 있음

- 스레드의 특성은 프로세스의 생성과 종료 과정에 매우 유용
    - 프로세스보다 스레드를 생성하는 것이 더 빠름
    - 동일한 프로세스에 있는 스레드 간의 교환이나 스레드 종료도 훨씬 빠름
    - 프로그램을 변경하지 않고 스레드를 병렬로 처리하여 효율 극대화
    

## 3. 스레드의 사용 예

현대 운영체제에서는 사용자 수준에서 적용가능

- 프로그램의 비동기적 요소를 구현하는 데 사용할 수도 있음
- 스레드를 사용자 수준에서 적용하면 운영체제와 무관하므로 속도가 매우 빠름
- 예) 워드 편집기

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-16.jpg" alt="그림 3-16" style="border:1px; border-style: solid; zoom:100%;"/>

- 스레드를 대기 상태로 바꾸고 제어를 다른 스레드를 옮기는 상태 변화를 이용하여 많은 요청을 효과적으로 처리 가능

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-17.jpg" alt="그림 3-17" style="border:1px; border-style: solid; zoom:100%;"/>

위 그림 같이 다중 스레드의 개념을 적용한 웹 브라우저는 스레드 한 개가 이미지나 텍스트를 로딩하는 동안 다른 스레드는 네트워크에 연결하여 데이터를 검색

- 스레드 단점
    - 사용자 수준 스레드는 커널 자체가 스레드 한 개로 구성
    - 스레드에서 시스템 호출을 실행하면 전체 작업이 이 시스템의 호출 결과를 받을 때까지 기다려야함
    

## 4. 스레드의 상태 변화

프로세스처럼 준비, 실행, 대기(보류), 종류 상태가 있음

- 스레드는 프로세서를 함께 사용하고 항상 하나만 실행
- 스레드는 순차적으로 실행
- 스레드의 정보를 저장하는 레지스터와 스택이 존재

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-18.jpg" alt="그림 3-18" style="border:1px; border-style: solid; zoom:100%;"/>

- 프로세스를 생성하면 스레드도 함께 생성
    - 스레드 생성에서는 부모 프로세스와 공유할 자원을 초기화할 필요없음
        - 해당 프로세스가 스택과 레지스터를 제공하기 때문
        
- 스레드 장점
    - 스레드 한 개가 대기 상태로 변할 때 전체 프로세스를 대기 상태로 바꾸지 않아도 됨
    - 실행 상태의 스레드가 대기 상태가 되어도 다른 스레드는 실행 가능
- 프로세스와 달리 서로 독립적이지는 않음
- 다른 스레드와 작업이 곂쳐지나 사용자 한 명이 여러 스레드로 개인 프로세스 하나를 소유하기 때문에 괜찮음

## 5. 스레드의 제어 블록

스레드도 프로세스처럼 스레드 제 블록(TCB)에 정보를 저장

- 프로세스는 스레드를 한 개 이상 가질 수 있음
- 프로세스 제어 블록은 스레드 제어 블록의 리스트를 가리킴

- 스레드 제어 블록은 프로세스 제어 블록과 유사
    - 레지스터값, 프로그램 카운터, 스택 포인터, 스케줄링 상태, 프로세스 포인터(스레드ID) 값 저장
- TCB 내용
    - 실행 상태: 프로세서 레지스터, 프로그램 카운터, 스택 포인터
    - 스케줄링 정보: 상태(실행, 준비, 대기) 우선순위, 프로세서 시간
    - 계정 정보
    - 스케줄링 큐용 다양한 포인터
    - 프로세스 제어블록(PCB)을 포함하는 포인터
    

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-19.jpg" alt="그림 3-19" style="border:1px; border-style: solid; zoom:100%;"/>

# 04 스레드의 구현

- 스레드는 다음 세 가지 형태로 구현한다.
    - 사용자 수준 스레드
        - 스레드 라이브러리를 이용하여 작동하는 형태
        - 다대일(n:1) 매핑
    - 커널 수준 스레드
        - 커널(운영체제)에서 지원하는 형태
        - 일대일(1:1) 매핑
    - 혼합형 스레드
        - 위 둘을 혼합한 형태
        - 다대다(n:m) 매핑
        

## 1. 사용자 수준 스레드

- 사용자 영역의 스레드 라이브러리로 구현
- 스레드와 관련 행위가 사용자 영역에서 하므로 커널이 스레드의 존재를 모름
- 스레드 교환에 커널이 개입하지 않음
    - 커널에서 사용자 영역으로 전환할 필요가 없음
    - 커널은 스레드가 아닌 프로세스를 한 단위로 인식하고 프로세서를 할당
        - 프로세스 테이블 유지
    - 다수의 사용자 수준 스레드가 커널 수준 스레드 한 개에 매핑
        - 다대일(n:1) 매핑
        

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-20.jpg" alt="그림 3-20" style="border:1px; border-style: solid; zoom:100%;"/>

- 사용자 영역에서 스레드를 구현할 때
    - 장점
        - 이식성이 높음
            - 커널에 독립적으로 스케줄링
        - 오버헤드가 적음
            - 스케줄링이나 동기화를 위해 커널을 호출 안함
            - 커널 영역으로 전환하는 오버헤드가 줄어듬
        - 유연한 스케줄링이 가능
            - 커널이 아닌 스레드 라이브러리에서 스레드 스케줄링을 제어
    - 단점
        - 시스템의 동시성을 지원하지 않음
            - 동일한 프로세스의 스레드 한 개가 대기 상태가 되면 이 중 어떤 스레드도 실행하지 못함
        - 확장에 제약이 따름
            - 커널이 한 프로세스에 속한 여러 스레드에 프로세서를 동시에 할당 불가
        - 스레드 간 보호 불가능
            - 스레드 간 보호에 커널의 보호 방법을 사용할 수 없음
            

## 2. 커널 수준 스레드

커널 수준 스레드는 사용자 수준 스레드의 한계를 극복하는 방법

- 커널이 스레드와 관련된 모든 작업을 관리
- 한 프로세스에서 다수의 스레드가 할당됨
    - 병행으로 수행 가능
    - 스레드 한 개가 대기 상태가 되면 동일한 위치의 다른 스레드로 교환이 가능
- 사용자 수준 스레드와 커널 수준 스레드가 일대일(1:1)로 매핑

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-21.jpg" alt="그림 3-21" style="border:1px; border-style: solid; zoom:100%;"/>

- 커널이 프로세스와 스레드 정보를 유지하여 오버해드가 커짐
    - 대신 스레드들을 병행으로 수행 가능
- 스레드 중 한 개가 대기 상태가 되더라도 다른 스레드를 실행할 수 있음
    - 대신 커널 영역으로 전환 오버헤드가 발생
    - 스케줄링과 동기화를 하려면 더 많은 자원 필요
    

## 3. 혼합형 스레드

사용자 수준 스레드와 커널 수준 스레드를 혼합한 구조

- 다수의 사용자 수준 스레드에 다수의 커널 스레드가 다대다(n:m)로 매핑
- 경량 프로세스를 시스템 호출로 생성
    - 커널 영역의 프로세스 문맥 안에서 실행
    - 커널로 독립적으로 스케줄링하여 다중 처리에서는 병렬로 실행

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter3/그림 3-22.jpg" alt="그림 3-22" style="border:1px; border-style: solid; zoom:100%;"/>

- 프로세스 하나에는 경량 프로세스가 하나
    - 경량 프로세스에는 커널 스레드가 한개
- 자원과 입출력 대기를 위해 경량 프로세스 단위로 대기
    - 프로세스는 입출력을 완료할 때까지 대기할 필요가 없음
    
- 위 그림의 각 프로세스를 하나씩 살펴보면 다음과 같음
    - 프로세스 1
        - 사용자 수준 스레드 한 개를 경량 프로세스 하나에 연결한 모습
    - 프로세스 2
        - 사용자 수준 스레드 3개가 더 적은 수인 경량 프로세스 2개에 매핑된 모습
    - 프로세스 3
        - 사용자 수준 스레드 2개를 경량 프로세스 2개에 연결
        - 사용자 수준 스레드 한 개를 경량 프로세스 한 개에 연결
        
- 커널이 경량 프로세스 수를 동적으로 조절
    - 사용자 수준 스레드와 커널 수준 스레드가 다대다(n:m)로 매핑
- 병행 실행이 의미 없을 때는 스레드 풀링을 이용하여 일대일(1:1) 매핑으로 오버헤드를 줄일 수 있음

- 스레드 풀링(thread pooling)
    
    시스템이 관리하는 스레드의 풀을 응용 프로그램에 제공하여 스레드를 효율적으로 사용할 수 있게 하는 방법
    
    미리생성한 스레드를 재사용하도록 하여 스레드를 생성하는 시간을 줄여서 시스템의 부담을 덜음
    
- 스레드는 중량 프로세스와 특징이 동일
    - 예) 다중 스레드 시스템인 매크는 커널이 여러 개의 요청을 동시에 서비스하도록 할 수 있음
    - 현재 실행하는 스레드가 대기 상태가 되면 다른 스레드를 실행
    
- 스레드의 기능
    - 스레드가 여러개인 프로세스 하나는 서버 스레드 한 개가 대기 상태일 동안 동일 프로세스의 다른 스레드를 실행
    - 작업량이 증가하고 시스템 전체의 성능이 향상