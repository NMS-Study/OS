# 04  병행 프로세스와 상호배제

## 01 병행 프로세스

### 1. 병행 프로세스의 개념

- 컴퓨터는 프로그램 작업을 수행하는 데 사용할 수 있는 여러 자원으로 구성

- 그 중 메모리 자원은 공유 영역에서 병렬로 사용

- 반면 입출력장치 일부나 프로세서는 한 번에 프로세스 하나만 사용할 수 있는 공유 자원

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-1.jpg" alt="그림 4-1" style="border:1px; border-style: solid; zoom:100%;"/>

- **병행 프로세스**
  - 운영체제가 프로세서를 빠르게 전환하여 프로세서 시간을 나눠 프로세스 여러 개를 동시에 실행하는 것처럼 보이게 하는 것
  - 병행 프로세스 구분
    - **독립 프로세스**
      - 단일 처리 시스템에서 수행하는 병행 프로세스
      - 다른 프로세스에 영향을 주고받지 않으면서 독립적으로 실행
      - 예) 단일 프로그래밍, 다중 프로그래밍, 다중 처리
    - **협력 프로세스**
      - 다른 프로세스와 상호작용하며 특정 기능을 수행하는 비동기적 프로세스
      - 필요 예시) 두 프로세스가 동일한 파일 사용, 프로세스가 읽을 떄 다른 프로세스가 쓰기를 함
      - 상호작용 형태
        - (1) 프로세스는 서로 인식하지 못하는 경쟁 관계를 유지
        - (2) 프로세스는 입출력 버스를 비롯한 개체를 공유하는 단계에서 간접적으로 서로의 관계를 인식
        - (3) 프로세스에는 서로를 인식하고 프로세스끼리 통신할 수 있는 기본 함수가 있음

> 병행성과 병렬성
> - 병렬성 : 다중 프로세서 시스템에서 동일한 시간에 별도의 프로세서에서 실행하는 것
> - 병행성 : 프로세스 수명이 겹치는 것이지 모두 동일한 시간에 실행할 필요는 없음

### 2. 병행 프로세스의 해결 과제

병행성은 여러 프로세스를 이용하여 작업을 수행하는 것으로, 다중 처리 시스템, 분산 처리 시스템뿐만 아니라 단일 프로세서로 운영하는 다중 프로그래밍 시스템에서도 매우 중요

- 병행성을 위해 해결해야할 문제
  - 공유 자원을 상호 배타적으로 사용
    - 예) 프린터, 통신망 등은 한순간에 프로세스 하나만 사용
  - 병행 프로세스 간에는 협력이나 동기화가 되어야함
  - 두 프로세스 사이에서는 데이터를 교환할 수 있도록 통신이 되어야 함
  - 프로세스는 동시에 수행하는 다른 프로세스의 실행 속도와 관계없이 항상 일정한 실행 결과를 보장하도록 결정성을 확보
  - 교착 상태를 해결하고 병행 프로세스들의 병렬 처리 능력을 극대화해야 함
  - 실행 검증 문제를 해결
  - 어떤 프로세스가 작업을 실행 중일 때 나머지 프로세스는 그것과 관련된 작업을 수행할 수 없도록 보장해야 함
- 다중 처리 시스템에서는 프로세서들이 모든 입출력장치와 메모리를 참조 가능
  - 동시에 동일한 자원에 접근할 떄 충돌이 발생할 수 있음
  - 충돌 해결 방법 필요

### 3. 선행 그래프와 병행 프로그램

프로그래밍 언어에서 문장 간의 선행 관계를 그래프로 표현하는 선행 그래프의 개념과 종류를 살펴봄

### 3.1. 선행 그래프

프로세스는 프로세스 집합과 이것의 선행 제약 두 가지 요소로 정의

- 선행 제약은 프로세스 순서대로 다른 상태로 옮기는 것
- 선행 그래프는 선행 제약을 논리적으로 표현한 것
- 노드 i에서 노드 j로 활동 j를 시작하기 전에 활동 i를 완료해야 한다는 순차적 활동을 표현하는 방향성 비순환 그래프
- 선행 그래프에서 노드는 소프트웨어 작업 또는 동시에 실행할 수 있는 프로그램 명령

다음은 간단한 산술 연산을 수행하는 알고리즘과 선행 그래프

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-2.jpg" alt="그림 4-2" style="border:1px; border-style: solid; zoom:100%;"/>

- 단일 프로그램에서도 여러 문장에 선행 제약이 들어 있음
  - s1과 s2는 서로 독립적으로 동시에 수행할 수 없음
  - s3은 a 값과 b 값을 할당받기 전에 수행하면 안됨
  - s4는 c 값을 계산하기 전에 수행할 수 없음
- 알고리즘 일부를 병행 수행
  - 이를 위해서는 프로세서 하나에 기능 단위를 여러 개 두기
  - 프로세서를 여러 개 사용
  - 총 수행 시간을 줄일 수 있음
- 선행 그래프는 각 문장에 대응하는 노드를 비순환 그래프로 나타냄

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-3.jpg" alt="그림 4-3" style="border:1px; border-style: solid; zoom:100%;"/>

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-4.jpg" alt="그림 4-4" style="border:1px; border-style: solid; zoom:100%;"/>

- 순환 선행 그래프에서 S3->S2, S2->S3 수행할 수 있는 선행 관계
- 이 제약은 동시에 만족할 수 없음
- 수행 순서를 정의할 수 없어 모순 발생

### 3.2. fork와 join 구조

- 선행 그래프는 연산의 선행 제약을 정의하는 데 유용하지만, 2차원이라 프로그램에는 사용하기 어려움
- 프로그램에 선행 관계를 명시하려면 fork와 join 구조, 병행 문장(parbegin/parend) 등 다른 방법이 필요
- **fork**
  - 프로그램에서 fork L 문장을 사용하면 병행 프로세스를 2개 만듦
  - 하나는 레이블이 L인 문장에서 수행
  - 다른 하나는 fork 명령어 바로 다음 문장에서 시작

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-5.jpg" alt="그림 4-5" style="border:1px; border-style: solid; zoom:100%;"/>

- **join**
  - 병행 연산 2개를 하나로 결합하는 방법 제공
  - 연산 2개 수행 중
    - 이 둘의 속도가 다르므로 둘 중 하나는 join을 먼저 수행하고 join 후 다른 연산을 수행
  - 연산 3개 수행 중
    - 연산 2개가 끝난 후 join한 결과와 나머지 연산을 join
    - 마지막 연산 하나를 남기고 나머지 연산을 모두 끝내려면 연산 수를 알기위해 매개변수로 명시

- join 명령어는 단위적으로 수행
  - join 문장 2개를 병행 수행하는 것은 두문장을 임의의 순서로 순차적으로 수행하는 것과 같음

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-6.jpg" alt="그림 4-6" style="border:1px; border-style: solid; zoom:100%;"/>

  - 산술 연산을 fork 명령어와 join 명령어를 이용하여 다음과 같이 시작

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-7.jpg" alt="그림 4-7" style="border:1px; border-style: solid; zoom:100%;"/>

- 그림 4-3의 선행 그래프를 fork와 join으로 표현 그림 4-8

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-8.jpg" alt="그림 4-8" style="border:1px; border-style: solid; zoom:100%;"/>

  - join 노드는 S7이 유일
  - 유입정도는 3
  - join에서 count의 초깃값은 3

- fork와 join 명령어는 병행 프로그램을 작성하는데 매우 효과적
- 제어 구조로는 어색
- fork 명령어의 수행 효과가 구조적 프로그래밍에서 사용을 자제하는 goto 문장과 비슷

### 3.3. 병행 문장

병행 문장은 하나의 프로세스가 여러 병렬 프로세스로 퍼졌다가 다시 하나로 뭉쳐지는것을 나타내는 고급 언어 구조

- 각 Si는 단일 문장
- parbegin과 parend 사이의 문장을 병행 수행
  
<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-9.jpg" alt="그림 4-9" style="border:1px; border-style: solid; zoom:100%;"/>

- Sn+1은 S(i=1, 2, 3, ... , n)이 끝난 후 실행
- 모든 문장이 실행한 후 Sn+1 결과가 된다면 그림 4-10처럼 표현 가능

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-10.jpg" alt="그림 4-10" style="border:1px; border-style: solid; zoom:100%;"/>

위 그림 4-2을 표현

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-11.jpg" alt="그림 4-11" style="border:1px; border-style: solid; zoom:100%;"/>

그림 4-3의 구조 알고리즘은 다음과 같음

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-12.jpg" alt="그림 4-12" style="border:1px; border-style: solid; zoom:100%;"/>

- 병행 문장은 블록 구조의 고급 언어에 쉽게 추가
- 다른 구조적 제어 문장의 장점을 보여줌

## 02 상호 배제와 동기화

### 1. 상호배제의 개념

병행 프로세스에서 프로세스 하나가 공유 자원을 사용할 때 다른 프로세스들이 동일한 일을 할 수 없도록 하는 방법

- 읽기 연산은 공유 데이터에 동시에 접근해도 문제가 발생하지 않음
- 공유 자원을 동시에 사용하지 못하게 실행을 제어하는 방법을 동기화
- 동기화는 순차적으로 재사용 가능한 자원을 공유하려고 상호작용하는 프로세스 사이에서 나타남
- 임계 자원과 임계 영역
  - 두 프로세스가 동시에 사용할 수 없는 공유 자원을 **임계 자원**이라고 함
  - 임계 자원에 접근하고 실행하는 프로그램 코드 부분을 **임계 영역**이라고 함
- 상호배제는 프로세스가 수정할 수 있는 공유 데이터에 접근할 때만 적용하고, 단순 읽기 등을 할 때는 동시에 수행하도록 허용해야함
- 상호배제는 프로세스가 수정할 수 있는 공유 데이터에 접근할 때만 적용
- 충돌하지 않는 연산을 할 때는 프로세스를 동시에 수행하도록 허용
- 만족해야하는 네 가지 조건
  - (1) 두 프로세스는 동시에 공유 자원에 진입할 수 없음
  - (2) 프로세스의 속도나 프로세서 수에 영향을 받지 않음
  - (3) 공유 자원을 사용하는 프로세스만 다른 프로세스를 차단할 수 있음
  - (4) 프로세스가 공유 자원을 사용하려고 너무 오래 기다려서는 안됨

### 2. 임계 영역

다수의 프로세스가 접근할 수 있지만, 어느 한순간에는 프로세스 하나만 사용

- 예) [그림 4-14]처럼 같이 입력과 출력 두 프로세스가 버퍼를 공통으로 사용하면 버퍼가 임계 영역이 되므로 두 프로세스는 동시에 버퍼를 사용하면 안됨

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-14.jpg" alt="그림 4-14" style="border:1px; border-style: solid; zoom:100%;"/>

- 임계 영역을 이용하면 간편하게 상호배제를 구현
- 임계 영역에 다른 프로세스가 있으면 이 프로세스는 다른 프로세스가 임계 영역에 들어가지 못하게 진입 상호배제를 수행
  
<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-15.jpg" alt="그림 4-15" style="border:1px; border-style: solid; zoom:100%;"/>

- 단 단일 머신 사이클에서 진행해야함
- 첫 번째 프로세스가 진입할 때 다른 프로세스도 진입하면, 임계 영역에 프로세스가 2개 있어 상호배제를 보장하지 않음
- 프로세스가 서로 협력하여 자원을 사용하도록 설계해야함

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-16.jpg" alt="그림 4-16" style="border:1px; border-style: solid; zoom:100%;"/>

- 임계 영역은 세가지 조건을 만족해야함
  - 상호배제 : 어떤 프로세스가 임계 영역에서 작업 중이면 다른 프로세스는 임계 영역으로 들어갈 수 없다
  - 진행 : 임계 영역에 프로세스가 없는 상태에서 여러 프로세스가 들어가려고 할 때는 어떤 프로세스가 들어갈지 적절히 결정해야 함
  - 한정 대기 : 다른 프로세스가 임계 영역을 무한정 기다리는 상황을 방지하려면 임계 영역에 한 번 들어갔던 프로세스는 다음에 임계 영역에 다시 들어갈 때 제한을 둔다.

### 3. 생산자/소비자 문제와 상호배제를 해결하는 초기의 시도

생산자/소비자 문제는 운영체제에서 비동기적으로 수행하는 모델로, 생산자 프로세스가 생산한 정보를 소비자 프로세스가 소비하는 형태

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-17.jpg" alt="그림 4-17" style="border:1px; border-style: solid; zoom:100%;"/>

- 생산자는 소비자에게 데이터를 전송할 때
  - 데이터를 소비자가 받을 준비가 되면 데이터를 전송하고 소비자가 계속 처리하지 못하면 대기
  - 이떄 생산자와 소비자가 불필요하게 공회전하지 않도록 데이터를 전송하는 방법 필요
    - 임시 기억장소인 버퍼를 도입하여 해결
    - 소비자가 데이터를 받을 준비를 마칠 때까지 생산자는 버퍼로 데이터를 전송하도록 하면 되는 것

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-18.jpg" alt="그림 4-18" style="border:1px; border-style: solid; zoom:100%;"/>

- 버퍼
  - 무한버퍼 : 버퍼의 크기가 무한
  - 유한버퍼 : 버퍼의 크기가 유한
<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-19.jpg" alt="그림 4-19" style="border:1px; border-style: solid; zoom:100%;"/>
  - 생산자가 이미 가득찬 버퍼에 더 채우려고 할 때, 소비자가 빈 버퍼에서 데이터를 꺼내려고 하면 문제 발생

- 무한 버퍼일 때
  - 생산자와 소비자가 독립적으로 알고림즘을 수행하도록 하여 버퍼를 잘 활용
  
<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-20.jpg" alt="그림 4-20" style="border:1px; border-style: solid; zoom:100%;"/>

- 유한 버퍼일 때
  - 논리적 포인터 in과 out 2개로 버퍼를 순환 배열로 구현하여 해결

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-21.jpg" alt="그림 4-21" style="border:1px; border-style: solid; zoom:100%;"/>

- 경쟁 상태 : 여러 프로세스가 동시에 공유 데이터에 접근할 때 접근 순서에 따라 실행 결과가 달라지는 상황
  - 공유 데이터에 마지막으로 남는 데이터의 결과를 보장할 수 없는 상황
  - 어느 프로세스를 마지막으로 수행한 후 결과를 저장했느냐에 따라 오류 발생
  - 읽기 명령을 수행하고 다음에 쓰기 명령을 수행하는 접근 순서화 필요
    - 공유 변수를 한순간에 프로세스 하나만 조작할 수 있도록하는 임계 영역과 연산하는 부분을 임계 영역으로 설정하여 상호배제하는 방법으로 해결

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-22.jpg" alt="그림 4-22" style="border:1px; border-style: solid; zoom:100%;"/>

## 03 상호배제 방법들

상호배제를 해결하는 데커 알고리즘, TestAndSet, 세마포, 모니터 정리

### 1. 데커 알고리즘

두 프로세스가 서로 통신하려고 공유 메모리를 사용하여 충돌 없이 단일 자원을 공유할 수 있도록 허용하는 데이터 알고리즘 개발

- 임계 영역에 진입 시도시 오직 하나만 임계 영역에 들어가도록 허용
- 각 프로세스는 플래그를 설정
  - 다른 프로세스 확인 후 플래그를 재설정 가능
- 프로세스가 임계 영역에 진입하고 싶으면 플래그를 설정하고 차례를 기다림

- 특징
  - 특별한 하드웨어 명령문이 필요 없음
  - 임계 영역 바깥에서 수행 중인 프로세스가 다른 프로세스들이 임계 영역에 들어가려는 것을 막지 않음
  - 임계 영역에 들어가기를 원하는 프로세서를 무한정 기다리게 하지 않음

### 2. TestAndSet(테스) 명령어

메모리 영역의 값에 대해 검사와 수정을 원자적으로 수행할 수 있는 하드웨어 명령어 TestAndSet을 이용하여 프로세스가 2개 이상일 때의 임계 영역 문제를 해결할 수 있음

- 하드웨어에서 명령을 사용하므로 알고리즘이 간단
- counter 공유 변수를 수정해서 발생하는 경쟁 상황을 해결
- 기계 명령어가 2개
  - 하나는 원자적 연산 명령어인 TestAndSet
  - TestAndSet에 지역변수 lock을 설정하는 명령어
- TestAndSet 명령어는 일부 시스템에서 원자 명령어의 하나
- 읽기와 쓰기 모두를 제공
- 해당 주소의 값을 읽고 새 값으로 교체하면서 해당 메모리 위치의 이전 값을 돌려줌

- 주요 기능
  - 임계 영역의 잠금과 프로세스 대기 상태를 이요하여 프로세스를 차단

- 장점과 단점
  - 장점
    - 사용자 수준에서 가능
      - 프로세스 수에 관계 없이 적용
      - lock 변수 수에 상관없이 구현
      - 구현이 단순, 확인이 용이
      - 다중 임계 영역 지원
  - 단점
    - 바쁜 대기 발생
      - 프로세서 시간 소모 큼
      - 대기 프로세스는 비생산적, 자원이 소모되는 대기 루프에 남음
    - 기아 상태 발생 : 하나 이상의 프로세스가 대기
    - 교착 상태 발생 : 우선순위가 낮은 프로세스는 lock, 우선순위가 높은 프로세스가 선점을 시도할 때 우선 순위가 높은 프로세스는 무한정 바쁜 대기가 됨

### 3. 세마포

### 3.1. 개념과 동작

- 세마포는 값이 음이 아닌 정수인 플래그 변수
- 가장 유명한 예는 열차의 진행 가능한 여부를 나타내는 차단기
- 차단기가 올라가면 차는 정지(자원이 없어 기다리는 상황)
- 차단기가 내려가면 차는 계속 진행(자원을 사용할 수 있는 자유 상태)
  
<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-23.jpg" alt="그림 4-23" style="border:1px; border-style: solid; zoom:100%;"/>
  
- 세마포 값은 true나 false로, P와 V 연산과 관련
- P는 검사, V는 증가, 세마포를 의미하는 S는 표준 단위 연산 P와 V로만 접근하는 정수 변수

- [그림 4-24]와 같이 S 값을 검사하여(S <= 0) 수정할 수 있는 S--는 인터럽트 없이 실행
- S에 대한 P 연산은 S 값을 검사하여 양수이면 1을 감소시키는 과정
- 검사, 인출, 감소, 저장 순서
- S에 대한 V 연산은 S를 1만큼 증가시키는 과정
- 인출, 증가, 저장 순서
- 교착 상태를 피하려고 단일 머신 사이클에서 단일 동작으로 수행
- 프로세스는 임계 영역에 진입하려고 wait(S)를 호출하여 임의의 다른 프로세스가 대기 조건을 통과하는 것을 방지
- 해당 프로세스가 임계 영역을 종료하면 다음 프로세스가 임계 영역에 진입할 수 있도록 signal(S)를 호출
- 여러 사용자와 생산자 문제처럼 동시 사용이 가능한 자원에서는 유용한 방법

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-25.jpg" alt="그림 4-25" style="border:1px; border-style: solid; zoom:100%;"/>

- 세마포에 적용된 P와 V 연산은 상호배제 개념을 포함하므로 프로세스 n개의 임계 영역 문제를 다룰 때 사용
- 동기화하는 데 사용할 수 있음

### 3.2. 세마포의 종류

- 계수 세마포와 이진 세마포가 있음

- 이진 세마포
  - 임계 영역에서 특별히 상호배제를 해결하려고 설계
  - 세마포 S를 상호배제에 사용
  - 1 또는 0으로 초기화
  - P와 V의 연산을 교대로 실행
  
<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-26.jpg" alt="그림 4-26" style="border:1px; border-style: solid; zoom:100%;"/>

- P(S) : S를 검사하여 양수이면 S를 0으로 재설정한 후 진행, 아니면 S를 준비 큐로 되돌림
- V(S) : S를 1로 설정하고 준비 큐에 있는 프로세스를 시작

- 이진 세마포는 처음 만들 때 사용 가능 상태이나, 사용 불가능 상태로 초기화할 수 있으므로 0이면 이용할 수 없거나 비었다고 생각할 수 있음

- 계수 세마포

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-28.jpg" alt="그림 4-28" style="border:1px; border-style: solid; zoom:100%;"/>

  - 생산자/소비자 문제처럼 상호배제와 조건부 동기화를 해결하려고 설계
  - 유한한 자원에 접근하는 것을 제어
  - 여러 번 획득하거나 해제할 수 있도록 count를 자원의 사용 허가 값으로 사용
  - 사용 가능한 자원 수로 초기화하므로, count를 초기의 세마포 수로 초기화
  - 각 프로세스가 자원을 사용하려면 P 연산을 수행하고 S(count)를 감소(S--)
  - 프로세스가 자원을 해제할 때는 V 연산을 수행하고 S(count)를 증가(S++)
  - 이진 세마포처럼 계수 세마포도 계수 세마포가 필요한 모든 프로세스가 공유할 수 있는 전역자원
  
### 4. 모니터

### 4.1. 모니터의 개념과 구조

사용자 사이에서 통신하려고 동기화하고, 자원에 배타적으로 접근할 수 있도록 프로세스가 사용하는 병행 프로그래밍 구조

- 공유 데이터, 임계 영역이 코딩된 프로시저, 초기화 코드로 구성된 모듈
  - 데이터 정의와 프로시저의 독점적 제어가 모두 포함
  - 초기화 코드는 모니터를 생성할 때만 사용
  - 공유 데이터의 변수는 모니터 내부에 있는 프로시저로만 접근
  - 프로세스들은 모니터의 프로시저를 호출 및 실행하여 모니터 안에 진입한 후 원하는 공유 데이터에 접근
- 한 번에 프로세스 하나만 모니터에 진입할 수 있도록 제한
  - 상호배제를 실현한다는 것이 중요
- 모니터 권한을 부여하지 않은 프로세스들은 준비 큐에서 진입을 기다리게 하여 상호배제를 실현

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-30.jpg" alt="그림 4-30" style="border:1px; border-style: solid; zoom:100%;"/>

- 모니터는 한순간에 프로세스 하나만 모니터 안에서 실행하도록 보장
  - 프로그래머가 동기화 제약 조건을 코드로 명시적으로 작성할 필요가 없음
  - 상대적으로 제어하기는 더 쉬움

- 모니터는 다중 프로세스 환경에서 프로세스 하나를 언제라도 모니터에 실행할 수 있도록 보장
  - 모니터 프로시저를 호출하면 호출 프로세스를 모니터에서 실행
  - 프로세스 2개가 동일한 모니터 프로시저를 호출 시 공유 데이터를 경쟁 상태의 프로세스로 동시에 변형 가능
  - 내재적 상호배제를 실현하고 공유 데이터의 완전성을 보장해야함
    - 즉, 프로세스가 모니터 프로시저를 호출할 때 이미 모니터에서 실행 중인 다른 프로세스가 있으면 호출 프로세스는 차단
    - 진입 권한이 없어 차단된 프로세스는 외부 모니터 준비 큐에서 대기
    - 프로세스를 실행하지 않아 모니터가 비면, 준비 큐의 프로세스 중 하나를 차단 해제 후 모니터 프로시저를 호출할 수 있는 권한 부여
    - 준비큐는 진입 순서는 있으나 입력 순서와는 무관

### 4.2. 조건 변수가 있는 모니터의 구조

- 임계 영역과 비슷
- 프로세스를 실행하는 동안 상호배제와 동기화를 제공
- 하지만, 강력함은 떨어져 동기화 방법을 추가로 정의해야함
- 모니터 외부에 있는 프로세스가 모니터에 있는 프로세스를 수행할 떄까지 외부에서 기다려야 할 때는 특정 조건에 따라 실행 재개를 결정
- 하나 이상의 모니터 조건 변수를 정의하여 모니터 안에서 작업을 동기화할 수 있음

<img width="500" src="../img/그림으로 배우는 구조와 원리 운영체제/Chapter4/그림 4-31.jpg" alt="그림 4-31" style="border:1px; border-style: solid; zoom:100%;"/>

