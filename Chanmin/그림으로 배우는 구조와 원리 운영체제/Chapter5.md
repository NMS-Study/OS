# 05 교착 상태와 기아 상태

## 01 교착 상태의 개념과 발생 원인

### 1. 교착 상태의 개념

- 교착 상태는 시스템 자원에 요구가 뒤엉킨 상태
- 두 프로세스가 사용하는 자원(비공유)을 서로 기다리고 있을 때 발생
- 다른 하나를 완료하지 않으면 프로세스를 더 이상 진행할 수 없고, 진행하지 않으면 프로세스를 완료할 수 없음
- 응용 프로그램의 프로세스는 대부분 자원 하나에 단독으로 접근하기보다는 여러 자원을 사용

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter5\그림 5-1.jpg" alt="그림 5-1" style="border:1px; border-style: solid; zoom:100%;"/>


- 한 프로세스 집합의 프로세스들이 일으킬 사건을 여러 프로세스가 서로 기다리고 있는 상태
- 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 교착 상태가 발생
- 예) 교통마비 상태

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter5\그림 5-2.jpg" alt="그림 5-2" style="border:1px; border-style: solid; zoom:100%;"/>

- 대화식 시스템에서 동적 자원을 공유하여 자원의 사용률을 높이는 과정에서 교착 상태가 발생

- 교착 상태는 제한된 자원의 사용을 높이고 시스템 효율성을 증가시키려고 사용하는 병행 처리 기술과 자원 공유에 따른 부작용

- 보통 프로세스는 다음 순서대로 자원을 사용
    - 자원 요청 : 프로세스가 필요한 자원을 요청
    - 자원 사용 : 프로세스가 요청한 자원을 획득하여 사용
    - 자원 해제 : 프로세스가 자원 사용을 마친 후 해당 자원을 되돌려 줌

- 자원의 요청과 해제는 시스템 호출로 함
- 파일이나 입출력장치 등 자원을 읽거나 쓰는 일도 시스템 호출로만 가능

### 2. 교착 상태의 예

- 스풀링 시스템에서 발생하는 교착 상태
    - 디스크에 할당된 스풀 공간의 출력을 완료하지 않은 상태에서 다른 작업이 스풀 공간을 모두 차지하면 교착 상태가 발생
    - 스풀링 처리부에 공간을 넉넉히 두면 교착 상태 발생률이 줄어들지만 비용이 많이 듬
    - 스풀링 파일의 일정 포화 임계치를 설정하여 교착 상태를 예방
    - 그러나 임계치를 줄이면 그만큼 시스템의 처리량이 줄어줌

- 디스크를 공유할 때 발생하는 교착 상태
    - 디스크 사용에 제어가 없으면 프로세스들이 서로 충돌하는 명령을 요청할 때 교착 상태가 발생

- 네트워크에서 발생하는 교착 상태
    - 네트워크가 붐비거나 입출력 버퍼 공간이 부족한 네트워크 시스템에 메시지 흐름을 제어하는 적절한 프로토콜이 없으면 그림 5-4 같이 교착 상태가 발생할 수 있음

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter5\그림 5-4.jpg" alt="그림 5-4" style="border:1px; border-style: solid; zoom:100%;"/>

### 3. 교착 상태의 발생 조건

- 발생 조건은 네 가지
- 1~3만 만족해도 교착 상태가 발생
- 4는 1~3 조건을 만족할 때 발생할 수 있는 결과
- 조건
    - (1) 상호배제
        - 한 번에 프로세스 하나만 해당 자원을 사용할 수 있어야 함
        - 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 함
    - (2) 점유와 대기
        - 자원을 최소한 하나 정도는 보유
        - 다른 프로세스에 할당된 자원을 얻으려고 기다리는 프로세스가 있어야 함
    - (3) 비선점
        - 자원은 강제로 빼앗을 수 없고, 자원을 점유하고 있는 프로세스가 끝나야 해제
    - (4) 순환 (환형) 대기
        - 보유한 자원을 각각 얻으려고 기다리는 것을 순환 대기

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter5\그림 5-5.jpg" alt="그림 5-5" style="border:1px; border-style: solid; zoom:100%;"/>

        - 컴퓨터에서 사용할 수 있는 자원의 종류를 알아보고, 이런 자원을 사용할 때 발생하는 교착 상태의 몇 가지 예를 살펴봄

    - 징검다리

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter5\그림 5-6.jpg" alt="그림 5-6" style="border:1px; border-style: solid; zoom:100%;"/>

        - 징검다리의 돌 하나를 자원, 사람을 프로세스
        - 돌 하나는 한 사람만 디딜 수 있음
        - 양쪽에서 두 명이 동시에 출발하여 징검다리 중간에서 만나면 교착 상태가 발생했다고 할 수 있음
        - 돌에 발을 딛는 것을 자원 할당
        - 돌에서 발을 떼는 것을 자원 해제
        - 동시에 같은 돌을 디디려 하면 교착 상태
        - 여기서 돌 하나를 한 사람만 디딜 수 있으므로 상호배제가 성립
        - 각 사람은 돌 하나를 딛고 다음 돌을 요구하므로 점유와 대기 조건도 만족
        - 사람이 딛고 있는 돌을 강제로 제거할 수 없으므로 비선점 조건도 만족
        - 끝으로 왼쪽에서 오는 사람은 오른쪽에서 오는 사람을 기다리고, 오른쪽에서 오는 사람도 왼쪽에서 오는 사람을 기다리므로 순환 대기 조건도 만족
        - 다음 방법으로 해결
            - 둘 중 한 사람이 되돌아 간다(복귀)
            - 징검다리 반대편을 먼저 확인하고 출발
            - 강의 한편에 우선순위를 부여


## 02 교착 상태의 해결 방법

(1) 교착 상태가 발생하지 않도록 예방<br>
(2) 교착 상태의 발생 가능성을 배제하지 않고 이를 적절히 회피<br>
(3) 교착 상태를 허용하되 교착 상태를 탐지하여 다시 회복<br>

### 1. 교착 상태 에방

- 교착 상태의 네 가지 조건이 하나라도 발생하지 않도록 하면 교착 상태를 예방

- 하벤더의 경우 상호배제를 제외한 다음 세 가지 교착 상태 예방 방법을 제안

    - 각 프로세스는 필요한 자원을 한 번에 모두 요청해야함
        - 요청한 자원을 모두 제공받기 전까지는 작업을 진행할 수 없음
    - 어떤 자원을 점유하고 있는 프로세스의 요청을 더 이상 허용하지 않으면 점유한 자원을 모두 반납하고 필요할 때 다시 자원을 요청
    - 모든 프로세스에 자원을 순서대로 할당해야 함
        - 모든 프로세스에 각 자원 유형별로 할당 순서를 부여한 후 순서에 따라 자원을 요청

- 보통 교착 상태는 다음 네 가지 방법으로 예방<br>
    (1) 자원의 상호배제 조건 방지<br>
    (2) 점유와 대기 조건 방지<br>
    (3) 비선점 조건 방지<br>
    (4) 순환(환형) 대기 조건 방지<br>

### 1.1. 자원의 상호배제 조건 방지

- 상호배제는 자원의 비공유가 전제
    - 예) 여러 프로세스는 프린터를 동시에 공유 불가
    - 공유 자원은 배타적인 접근이 필요 없어 교착 상태 발생 X
    - 읽기 전용 파일은 공유 자원의 좋은 예
- 파일 쓰기는 배타적인 접근만 허용해야 함
    - 하나 이상의 프로세스에 쓰기 권한이 동시에 있으면 교착 상태가 발생할 수 있음

### 1.2. 점유와 대기 조건 방지

- 점유와 대기 조건이 발생하지 않으려면, 프로세스가 작업을 수행하기 전에 필요한 자원을 모두 요청하고 획득해야함
- 프로세스가 실행에 필요한 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류하여 대기 조건이 성립하지 않도록 함
- 대기 상태에서는 프로세스가 자원을 점유할 수 없으므로 대기 조건이 성립하지 않음
    - 이때를 최대 자원 할당이라함
- 점유와 대기 조건을 방지하는 방법<br>
    (1) 자원을 할당할 때 시스템 호출된 프로세스 하나를 실행하는 데 필요한 모든 자원을 먼저 할당하여 실행한 후 다른 시스템 호출에 자원을 할당<br>
    (2) 프로세스가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용 

- 단점
    - 자원의 효율성이 너무 낮음
    - 기아 상태가 발생

### 1.3. 비선점 조건 방지

- 전제 조건은 이미 할당된 자원에 선점권이 없어야 함
- 프로세스가 어떤 자원을 요청할 때 요청한 자원이 사용 가능한지 검사
- 사용할 수 있따면 자원을 할당하고 사용할 수 없다면 대기 프로세스가 요청한 자원을 점유하고 있는지 검사
- 요청한 자원을 대기 프로세스가 점유하고 있다면 자원을 해제하고 요청 프로세스에 할당
- 요청한 자원을 사용할 수 없거나 실행 중인 프로세스가 점유하고 있다면 요청 프로세스는 대기
- 프로세스가 대기하는 동안 다른 프로세스가 점유한 자원을 요청하면 자원을 해제할 수 있음

### 1.4. 순화(환형) 대기 조건 방지

- 모든 자원에 일련의 순서를 부여
- 각 프로세스가 오름차순으로만 자원을 요청할 수 있게함
- 이는 계층적 요청 방법
    - 순환 대기의 가능성을 제거하여 교착 상태를 예방 가능
- 그러나 예상된 순서와 다르게 자원을 요청하는 작업은 실제로 자원을 사용하기 훨씬 전부터 오랫동안 자원을 할당받은 상태로 있어야함
    - 상당한 자원 낭비를 초래

- 교착 상태를 예방하기 위한 규칙
    - 각 프로세스는 오름차순으로만 자원들을 요청
    - 데이터 형태 자원이 여러 개 필요하다면 요청할 형태 자원을 하나 정해야 함

- 계층적 요청은 순환 대기 조건 가능성을 제거하여 교착 상태를 예방
- 하지만 반드시 자원의 번호 순서로 요청해야 한다는 부담
- 순환 대기 조건 방지는 프로세스의 속도를 떨어뜨리고 자원 접근을 불필요하게 거부하기 때문에 비효율적 

### 2. 교착 상태 회피

- 덜 엄격한 조건을 요구하여 자원을 좀 더 효율적으로 사용하는 것이 목적
- 교착 상태가 발생할 가능성을 인정(세 가지 필요조건 허용)
- 교착 상태가 발생하려고 할 떄 적절히 회피
- 예방보다는 회피가 더 병행성을 허용
- 두 가지 교착 상태의 회피 방법
    - 프로세스의 시작 중단
        - 프로세스의 요구가 교착 상태를 발생시킬 수 있따면 프로세스 시작을 중단
    - 자원 할당 거부
        - 프로세스가 요청한 자원을 할당했을 떄 교착 상태가 발생할 수 있따면 요청한 자원을 할당하지 않음

### 2.1. 프로세스의 시작 중단

- 교착 상태를 회피하려면 자원을 언제 요청하는지 추가 정보가 필요
- 프로세스의 요청을 수락할지, 기다리게 할지 여부는 현재 사용 가능한 자원, 프로세스에 하달된 자원 등 각 프로세스에 대한 자원의 요청과 해제를 미리 알고 있어야 결정할 수 있음
- 다양한 교착 상태 회피 알고리즘 중, 가장 단순하고 유용한 알고리즘은 각 프로세스가 필요한 자원의 최대치(할당 가능한 자원 수)를 선언하는 것
- 프로세스가 요청할 자원별로 최대치 정보를 미리 파악할 수 있으면 시스템이 교착 상태가 되지 않을 확실한 알고리즘을 만들 수 있음
<br>
<br>
- 교착 상태 회피 알고리즘은 시스템이 순환 대기 조건이 발생하지 않도록 자원 할당 상태를 검사
- 자원 할당 상태는 사용 가능한 자원 수, 할당된 자원 수, 프로세스들의 최대 요청 수로 정의
- 시스템에 안정 순서가 있으면 그 시스템은 안정
    - 안전 순서는 점유한 자원들로 충족할 수 있다는 의미
    - 이때 프로세스가 필요한 자원을 즉시 사용할 수 없다면 끝날 때까지 기다렸다가 자원을 확보
    - 필요한 모든 자원을 확보하면 지정된 작업을 끝내고 자원을 해제
    - 종료하면 필요한 자원을 확보할 수 있으므로 처리를 계속 진행할 수 있음
    - 이런 순서가 없으면 시스템 상태를 불안정하다고 봄
    - **시스템 상태**
        - 아래 그림과 같이 안정 상태와 불안정 상태로 나눌 수 있음
        - 교착 상태는 불안정 상태에서 발생
        - 모든 사용자가 일정 기간 안에 작업을 끝낼 수 있도록 운영체제가 할 수 있으면 현재 시스템의 상태가 안정
            - 그렇지 않으면 불안정
        - 오해하면 안되는 부분이 불안정 상태는 교착 상태가 되기 쉬울 뿐임

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter5\그림 5-12.jpg" alt="그림 5-12" style="border:1px; border-style: solid; zoom:100%;"/>

- 안정 상태 개념에서 교착 상태 회피 알고리즘을 정의할 수 있음
- 시스템이 항상 안정 상태에 머물러 있도록 하는 단순한 방법
- 자원을 할당한 후에도 시스템이 항상 안정 상태에 있을 떄만 할당을 허용하면 됨

### 2.2. 자원 할당 거부(은행가 알고리즘)

- 은행가 알고리즘은 자원의 할당 허용 여부를 결정하기 전에 미리 결정된 모든 자원의 최대 가능한 할당량을 시뮬레이션하여 안전 여부를 검사
- 다음 대기 중인 다른 모든 활동의 교착 상태 가능성을 조사하여 '안전 상태' 여부를 검사 및 확인

<br>
<br>

- 은행가 알고리즘은 자원 요청을 승낙하는 것이 불안전한 상태에서 시스템을 배치할 수 있다고 판단하면 이 요청을 연기하거나 거부하여 교착 상태를 예방
- 각 프로세스에 자원을 어떻게 할당(자원 할당 순서 조정)할 것인지 정보가 필요
    - 각 프로세스가 요청하는 자원 종류의 최대 수를 알아야 함

<br>
<br>

- 작업에 대한 은행가 알고리즘은 각 프로세스는 얼마큼 자원의 요청이 가능하고, 각 프로세스는 현재 얼마큼 자원을 보유하고 있으며, 시스템은 얼마큼 각 자원을 사용할 수 있는지 등 정보가 필요

- 은행가 알고리즘을 구현하려고 다양한 자료구조를 유지
- 자료구조는 자원 할당 시스템의 상태를 나타냄
- n을 시스템의 프로세스 수, m을 자원 수라고 하면 다음 자료구조가 필요

    - Available : 각 형태별로 사용 가능한 자원 수(사용 가능량)를 표시하는 길이가 m인 벡터
    - Max : 각 프로세스 자원의 최대 요청량을 포시하는 n x m 행렬
    - Allocation : 현재 각 프로세스에 할당되어 있는 각 형태의 자원 수를 정의하는 n x m 행렬
    - Need : 각 프로세스에 남아 있는 자원 요청을 표시하는 n x m 행렬

<br>
<br>

- 은행가 알고리즘은 교착 상태를 회피하려고 교착 상태가 일어나지 않을 때만 작업을 진행 시킴
- 이에 따른 단점
    - 일정하게 남아 있는 자원 수를 파악하기가 매우 어렵
    - 사용자 수가 일정해야 하지만 다중 프로그래밍 시스템에서는 사용자 수가 항상 변함
    - 교착 상태 회피 알고리즘을 실행하면 시스템 과부하가 증가
    - 프로세스는 자원을 보유한 상태로 끝낼 수 없음
    - 사용자의 최대 필요량을 파악하기가 어렵
    - 항상 불안정 상태를 방지해야 하므로 자원 이용도가 낮음

### 3. 교착 상태 회복

교착 상태에서 회복하려면 다음 알고리즘이 필요

- 시스템 상태를 검사하는 교착 상태 탐지 알고리즘
- 교착 상태에서 회복시키는 알고리즘

<br>
<br>

- 교착 상태 탐지 알고리즘을 언제 수행해야 하는지 결정하기란 쉽지 않음
- 자주 실행하면 시스템의 성능이 떨어짐
- 그러나 실행하면 교착 상태에 빠진 프로세스를 빨리 발견하여 자원의 유휴 상태를 방지 가능
    - 자주 실행하지 않으면 반대의 상황이 발생

### 3.1. 교착 상태 탐지 알고리즘

교착 상태 탐지 알고리즘에서 사ㅡ용한 자료구조

- Available : 자원마다 사용 가능한 자원 수를 표시하는 길이가 m인 벡터
- Allocation : 각 프로세스에 현재 할당된 각 형태들의 자원 수를 표시하는 n x m 행렬
- Request : 각 프로세스의 현재 요청을 표시하는 n x m 행렬

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter5\그림 5-19.jpg" alt="그림 5-19" style="border:1px; border-style: solid; zoom:100%;"/>

- 2단계 "Request <= Work"임을 확인하자마자 3단계에서 프로세스 Pi의 자원을 변환하는 이유는 Pi가 현재 교착 상태에 있지 않다는 것을 알 수 있기 때문
- Pi는 자신의 작업을 종료하려고 더 이상 자원을 요청하지 않을 것이라고 가정
- 그렇지 않으면 이후에 교착 상태가 발생할 수 있음

<br>
<br>

- 탐지 알고리즘 호출 문제는 교착 상태 발생 빈도수와 교착 상태가 발생했을 때 영향을 받는 프로세스 수에 따라 결정
- 교착 상태가 자주 발생하면 탐지 알고리즘도 더 자주 호출해야됨
- 그리고 해결할 때까지 프로세스에 할당된 자원들은 유휴 상태가 됨
- 교착 상태의 프로세스 수는 점점 늘어남
- 요청이 발생할 때마다 교착 상태 탐지 알고리즘을 호출하면 교착 상태를 회피할 수 있만 연산 시간 부담이 큼
- 그래서 경제적인 방법은 호출 빈도를 줄이고 1시간 마다 또는 cpu 이용률을 40%로 떨어트려 호출하는 것

### 3.2. 교착 상태 회복 방법

- 교착 상태에서 회복한다는 것은 순환 대기에서 벗어난다는 것
- 단순하게 프로세스를 한개 이상 중단하는 방법과 교착 상태의 프로세스들에서 자원을 선점하는 방법이 있음

<br>
<br>

- **프로세스 중단**<br>
    프로세스를 중단하여 교착 상태에서 회복하는 방법은 다음 두 가지
    - 교착 상태 프로세스를 모두 중단 : 오랫동안 연산했을 가능성이 있는 프로세스의 부분 결과를 폐기하여 나중에 다시 연산해야 함
    - 한 프로세스씩 중단 : 한 프로세스를 중단할 때마다 교착 상태 탐지 알고리즘을 호출하여 프로세스가 교착 상태에 있는지 확인

- 프로세스를 중단하는 것이 쉽지 않을 수도 있음
- 프로세스가 파일을 업데이트하다가 중단 된다면 해당 파일은 부정확한 상태가 됨

- 부분 종료 방법을 이용하여 교착 상태에서 벗어나려면 어떤 프로세를 중단시킬지 결정해야함
    - 이것은 프로세서 스케줄링과 비슷한 정책 결정 문제
    - 최소 비용으로 프로세스들을 중단하는 방법을 찾는 것

        - 프로세스의 우선순위
        - 프로세스가 수행된 시간과 앞으로 종료하는데 필요한 시간
        - 프로세스가 사용한 자원 형태와 수
        - 프로세스를 종료하는 데 필요한 자원 수
        - 프로세스를 종료하는 데 필요한 프로세스 수
        - 프로세스가 대화식인지, 일괄식인지 여부

- **자원 선점**<br>
    자원 선점을 이용하여 교착 상태를 해결하려면 프로세스의 자원을 선점해서 교착 상태를 해결할 때까지 선점한 자원을 다른 프로세스에 할당해야 함<br>
    선점권을 이용하여 교착 상태를 처리하려면 세 가지 사항을 해결해야 함
    - **선점 자원 선택** : 프로세스를 종료할 때 비용을 최소화하려면 적절한 선점 순서를 결정해야함, 비용 요인에는 교착 상태 프로세스가 점유한 자원 수, 교착 상태 프로세스가 지금까지 실행하는 데 소요한 시간 등 매개변수가 포함
    - **복귀** : 필요한 자원을 잃은 프로세스는 정상적으로 실행할 수 없음. 따라서 프로세스를 안정 상태로 복귀시키고 다시 시작
    - **기아** : 동일한 프로세스가 자원들을 항상 선점하지 않도록 보장하려고 할 때 비용이 기반인 시스템에서는 동일한 프로세스를 희생자로 선택, 이 프로세스는 작업을 완료하지 못하는 기아 상태가 되어 시스템 조치를 요청

<br>
<br>

- 이제까지의 교착 상태를 처리하는 기본 방법인 예방, 회피, 탐지, 회복으로 한 가지만으로는 모든 문제를 해결하기는 불가능
- 세 가지 기본 방법을 결합하여 시스템 자원의 형태마다 최적의 접근 방법을 채택하는 자원의 계층적 순서를 활용

## 03 기아 상태

자원 부족의 기아 상태는 사용할 수 없는 자원을 계속 기다리는 결과를 예방하려고 자원을 할당할 때 발생하는 결과

- 교착 상태의 해결책은 기아 상태의 가능성을 제거하지 못함
- 기아 상태 해결은 먼저 기다리는 작업을 발견하고 각 작업이 기다린 시간을 조사 추적해야함
- 시스템은 기아 상태를 발견하면 즉시 새로운 작업의 시작을 대기 하도록 조치해야함