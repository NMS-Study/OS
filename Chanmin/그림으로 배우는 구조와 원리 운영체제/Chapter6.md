# 06 프로세스 스케줄링

## 01 스케줄링의 이해

### 1. 스케줄링의 개념

- 스케줄링은 여러 프로세스가 번갈아 사용하는 자원을 어떤 시점에 어떤 프로세스에 할당할지 결정하는 것

- 스케줄링 방법에 따라 프로세서를 할당받을 프로세스를 결정하므로 스케줄링이 시스템의 성능에 영향을 미침

- 좋은 스케줄링은 효율성을 높이고, 작업(프로세서)의 응답시간을 최소화하여 시스템의 작업 처리 능력을 향상시킴

- 자원의 공유 순서나 일정을 조정하는 스케줄링에서는 사용자 프로세스와 시스템 프로세스를 다룸

### 2. 스케줄링의 목적

- **자원 할당의 공정성 보장** : 모든 프로세스를 공평하게 취급, 어떤 프로세스도 실행을 무한 연기해서는 안됨

- **단위 시간당 처리량 최대화** : 단위시간당 유효 시간을 줄이고 프로세서의 처리량을 최대화하여 가능한 많은 프로세스에 서비스를 제공

- **적절한 반환시간 보장** : 적절한 시간 안에 응답(프로세스 완료)을 해야 함

- **예측 가능성 보장** : 작업을 시스템 부하와 상관없이 거의 같은 시간에 거의 같은 비용으로 실행할 수 있어야 함

- **오버헤드 최소화** : 일반적으로 오버헤드가 발생하면 자원이 낭비되므로 오버헤드를 줄여야 함

- **자원 사용의 균형 유지** : 시스템의 자원을 가능한 쉬지 않고 사용할 수 있도록 스케줄링 해야 함

- **반환시간과 자원의 활용 간에 균형 유지** : 반환시간을 빠르게 하는 방법은 충분한 자원을 확보하는 것이지만 한 프로세스가 너무 많은 자원을 차지하면 시스템의 자원 활용도가 떨어짐, 실시간 시스템은 빠른 응답이 필요하므로 자원 활용이 상대적으로 덜 중요하지만 다른 형태의 시스템에서는 효과적인 자원 활용이 더 중요

- **실행 대기 방지** : 실행을 무한 연기하지 않도록 해야함

- **우선순위** : 우선순위를 부여한 후 스케줄링 방법을 이용하여 우선순위가 높은 프로세서를 먼저 실행 하도록 함

- **서비스 사용 기회 확대** : 프로세스에 더 자주 서비스 사용 기회를 주어야 함

- **서비스 수 감소 방지** : 서비스 수가 갑자기 감소해서는 안됨, 시스템 부하가 많이 걸릴 때 갑자기 서비스 수가 감소하면 안됨

### 3. 스케줄링의 기준 요소

- 프로세스를 프로세서에서 실행할 때를 프로세서 버스트라고 함

- 입출력 버스트는 프로세스가 추가로 실행하려고 입출력을 기다리고 있을 때

- 프로세스는 입출력 버스트 후 다음 프로세서 버스트를 위해 준비 큐로 이동

- 프로세스의 실행은 아래 그림과 같이 프로세서 버시트와 입출력 버스트의 순환 형태로 구성

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-1.jpg" alt="그림 6-1" style="border:1px; border-style: solid; zoom:100%;"/>


- 프로세서 버시트는 입출력 대기시간에 따라 사용량이 결정

- 프로세서 버스트(실행 지속 시간)는 지수 성질이 있어 아래 그림과 같은 형태의 빈도 곡선으로 나타냄

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-2.jpg" alt="그림 6-2" style="border:1px; border-style: solid; zoom:100%;"/>

- 짧은 프로세스가 많이 분포되어 있는 그림

- 긴 프로세서 버스트는 프로세서를 점유한 상태로 화면에서 모든 입력과 출력을 처리하거나 파일에서 입력과 출력을 하지 않고 메모리와 레지스터에서 오랫동안 하는 작업 
    - 백그라운드 프로그램은 일반적으로 파일 읽기와 쓰기를 함

- 아래 그림은 프로세스의 입출력 대기시간이 긴 예와 짧은 예

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-3.jpg" alt="그림 6-3" style="border:1px; border-style: solid; zoom:100%;"/>

- 입출력 중심 프로세스는 프로세서 버스트가 매우 짧음
    - 입출력 중심 작업
    
- 프로세서 중심 프로세스는 프로세서 버스트가 매우 김
    - 프로세서 중심 작업

- 두 중심 작업의 적절한 혼합은 스케줄링 알고리즘을 선택할 때 매우 중요한 기준

### 4. 스케줄링의 단계

- 1단계 작업 스케줄링 : 작업 선택
    - 실제로 시스템 자원을 사용할 작업을 결정하는 작업 스케줄링
    - 작업 스케줄링에 따라 작업을 프로세스들로 나눠 생성

- 2단계 작업 승인과 프로세서 결정 스케줄링 : 사용 권한 부여
    - 프로세서를 사용할 권한을 부여할 프로세스를 결정하는 작업 승인과 프로세서할당 스케줄링
    - 이 단계는 1단계 작업 스케줄링과 3단계 프로세서 할당 스케줄링의 완충 역할

- 3단계 프로세서 할당 스케줄링 : 준비 상태의 프로세스에 프로세서 할당(디스패칭)
    - 이 단계는 디스패처(분배기)가 준비 상태에 있는 프로세스 중에서 프로세서를 할당할 프로세스를 결정하는 프로세스 할당 스케줄링

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-4.jpg" alt="그림 6-4" style="border:1px; border-style: solid; zoom:100%;"/>

### 5. 스케줄링 큐

- 스케줄링에서는 아래 그림과 같이 다양한 큐를 사용

- 준비 큐는 프로세서를 할당받아 실행하려고 기다리는 프로세스들이 대기함

- 입출력 장치 큐는 입출력 장치를 사용하려는 프로세스들이 대기함

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-5.jpg" alt="그림 6-5" style="border:1px; border-style: solid; zoom:100%;"/>

- 큐를 자세히 살펴보면 아래 그림 같이 프로세스 제어 블록을 연결 리스트로 연결하고 있는 형태

- 큐에는 머리와 꼬리가 있고 각각 연결된 첫 번째 프로세스 제어 블록과 마지막 프로세스 제어 블록의 포인터 필드를 가리킴

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-6.jpg" alt="그림 6-6" style="border:1px; border-style: solid; zoom:100%;"/>

### 6. 스케줄링과 스케줄러

- 스케줄러는 먼저 스케줄링을 표현하는 방법을 알아야 이해할 수 있음

- 큐잉 도표가 대표적인 방법

### 6.1. 큐잉 도표

- 큐잉 도표는 프로세스 스케줄링을 표현하는 방법

- 아래 그림과 같이 큐는 사각형, 자원은 원, 프로세스의 흐름은 화살표임

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-7.jpg" alt="그림 6-7" style="border:1px; border-style: solid; zoom:100%;"/>

- 작업이 시스템에 들어오면 작업의 프로세스 제어 블록을 생성, 이는 작업을 종료할 때까지 갱신

- 실행 준비가 된 프로세스가 준비 큐에 들어가고 프로세서를 할당받을 때까지 대기

- 프로세스에 프로세서가 할당되면 다음 사항 중 하나가 일어남

(1) 프로세스가 입출력 요청을 보내고 입출력 큐에 들어감<br>
(2) 프로세스가 새로운 프로세스를 생성하고 생성한 프로세스의 종료를 기다림<br>
(3) 프로세스가 시간 할당량을 초과하면 준비 큐에 들어감<br>
(4) 인터럽트로 프로세서에서 제거된 프로세스는 다시 준비 큐에 들어감<br>

### 6.2. 스케줄러의 종료와 역할

**장기 스케줄러와 단기 스케줄러**

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-8.jpg" alt="그림 6-8" style="border:1px; border-style: solid; zoom:100%;"/>

- 장기 스케줄러
    - 작업 스케줄러라고함
    - 스케줄링에 따라 디스크에서 메모리로 작업을 가져와 처리할 순서를 결정
    - 작업 스케줄링에 필요한 정보로 제출 시간, 작업 이름, 작업 길이 등이 있음
    - 선택한 작업에 프로세스 제어 블록을 부착시켜 메모리를 적재한 것이 프로세스

- 단기 스케줄러
    - 메모리에 적재된 프로세스 중 프로세서를 할당하여 실행 상태가 되도록 결정하는 프로세스 스케줄링을 함
    - 프로세스가 실행하는 데 필요한 자원의 요청을 만족해야함

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-9.jpg" alt="그림 6-9" style="border:1px; border-style: solid; zoom:100%;"/>

- 장기 스케줄러와 단기 스케줄러의 가장 큰 차이는 실행 빈도
    - 단기 스케줄러는 실행할 프로세스를 수시로 선택
    - 장기 스케줄러는 시스템에 새로운 작업이 분 단위로 들어오므로 단기 스케줄러에 비해 상대적으로 드물게 수행

- 어떤 시스템에서는 장기 스케줄러가 없거나 그 역할이 작음

- 따라서 중기 스케줄러를 추가로 사용

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-10.jpg" alt="그림 6-10" style="border:1px; border-style: solid; zoom:100%;"/>

- 중기 스케줄러
    - 프로세스들이 프로세서를 서로 차지하려고 할 때 프로세스를 별도의 기억 장소에서 빼낼 수 있어 다중 프로그래밍의 정도를 줄일 수 있음

    - 시간이 흐른 후 빼낸 프로세스는 다시 메모리에 들어가 실행을 중단한 곳부터 다시 실행
    - 이 방법을 **스왑**이라고 함

    - 스왑 인과 스왑 아웃을 중기 스케줄러가 결정

    - 스왑
        - 작업의 혼합을 개선하거나 프로세스가 가지고 있던 메모리를 사용할 수 있게 하는 데 필요

- 아래 그림과 같이 단기 스케줄러는 디스패처를 포함할 수 있음
- 디스패처는 단기 스케줄러가 선택한 프로세스에 실질적으로 프로세서를 할당하는 역할을 하는 모듈

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-11.jpg" alt="그림 6-11" style="border:1px; border-style: solid; zoom:100%;"/>

- 살펴본 스케줄러들이 프로세스 상태 변환에서 어떤 역할을 하는지 그 관계를 살펴보면 아래와 같음

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-12.jpg" alt="그림 6-12" style="border:1px; border-style: solid; zoom:100%;"/>

- 장기 스케줄러는 프로세스의 생성 과정에서 프로세스의 준비 상태에 무엇을 추가할지 결정, 메모리의 사용 가능 공간과 자원을 확인

- 중기 스케줄러는 스왑 기능의 일부로 메모리에 부분적으로 프로세스를 적재, 일시중지된 프로세서의 원인을 해결하면 다시 준비 상태로 만듬

- 단기 스케줄러는 미리 정한 스케줄링 알고리즘에 따라 실행할 프로세스를 선택

### 7. 선점 스케줄링과 비선점 스케줄링

- 스케줄링 알고리즘은 선점 스케줄링과 비선점 스케줄링의 개념으로 '실행 중인 작업이나 프로세스를 실행 중 중단할 것인가?'하는 관점을 바탕으로 스케줄링을 구분한 것

- 한 프로세스가 자원을 선택했을 때 다른 프로세스가 해당 자원을 빼앗을 수 없다면 비선점 스케줄링
- 현재 실행 중인 프로세스를 인터럽트할 수 있거나 준비 상태로 이동할 수 있다면 선점 스케줄링

- 선점 스케줄링은 프로세스 하나가 장시간 동안 프로세서를 독점하는 것을 방지하기 때문에 모든 프로세스에 프로세서를 서비스할 기회를 늘릴 수 있음

- 선점 스케줄링은 오버헤드가 커질 수 있어 이를 효과적으로 이용하려면 메모리에 프로세스가 많이 적재되어 있어야 함

    - 프로세서를 사용 가능할 때마다 실행할 수 있는 프로세스들이 준비 상태에 있어야 효과적

- 비선점 시스템에서는 실행 시간이 짧은 프로세스가 실행 시간이 긴 프로세스를 기다리는 대신 모든 프로세서를 공정하게 관리

### 8. 스케줄링 알고리즘의 선택 기준

- 다양한 스케줄링 알고리즘 중에서 하나를 선택할 때는 그 특성을 충분히 고려해야함

- 다음은 스케줄링 알고리즘을 비교할 때 참조할 수 있는 기준

    - 프로세서 사용률 : 프로세서를 항상 실행 상태로 유지하여 유휴 상태가 되지 않도록 함
    - 처리율 : 단위시간당 완료하는 작업 수가 많도록 짧은 작업을 우선 처리하거나 인터럽트 없이 작업을 실행
    - 반환시간 : 작업이 메모리에 들어가기까지 걸린 시간, 준비 큐에 머무는 시간, 실행 시간, 입출력 시간 등 작업을 완료하는 데 소요되는 시간을 최소화하도록 일괄 처리 작업을 우선 처리
    - 대기시간 : 작업의 실행 시간이나 입출력 시간은 영향을 줄 수 없으므로 준비 큐에서 기다리는 시간을 최소화하도록 사용자 수를 제한
    - 반응시간 : 작업을 요청한 시간부터 반응을 시작하는 시간까지 간격으로, 대화형 시스템에 중요한 사항. 대화식 작업을 우선 처리하고 일괄 처리 작업은 대화식 작업을 요청하지 않을 때 처리

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-13.jpg" alt="그림 6-13" style="border:1px; border-style: solid; zoom:100%;"/>

## 02 스케줄링 알고리즘

- 스케줄러가 스케줄링 알고리즘에 따라 프로세서를 할당하고 작업을 완료

- 여기서는 단일 처리 시스템을 기준을 주요 스케줄링 알고리즘을 소개

### 1. 선입선처리 스케줄링

- 비선점 방법으로 프로세서 스케줄링 알고리즘 중 가장 단순

- 프로세서를 요청하는 순서대로 프로세서를 할당, 선입선출(FIFO) 큐로 구현

- 일괄 처리 시스템에서는 매우 효율적이나 빠른 응답을 요청하는 대화식 시스템에는 적합하지 않음

- 이는 아래 그림과 같이 시스템에 새로운 프로세스가 들어오면 해당 프로세스의 프로세스 제어블록을 준비 큐의 마지막에 연결

- 차례가 되면 준비 큐의 앞부분에 있던 프로세스가 프로세서를 할당받고 준비 큐에서 삭제

- 선입선처리는 대부분 성능이 좋지 않고 평균 대기시간이 길 때도 있음

- 선입선처리 스케줄링 알고리즘은 비선점식

- 프로세서를 점유한 프로세스가 종료하든지 입출력을 요청하여 자신의 프로세서를 해제하기 전까지는 프로세서를 계속 점유하므로 시분할 시스템에서는 사용하기 곤란

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-15.jpg" alt="그림 6-15" style="border:1px; border-style: solid; zoom:100%;"/>

- 장점과 단점
    - 장점
        - 스케줄링의 이해와 구현이 단순
        - 준비 큐에 있는 모든 프로세스가 결국 실행되므로 기아 없는 공정한 정책
        - 프로세서가 지속적으로 유용한 프로세스를 수행하여 처리율이 높음

    - 단점
        - 비선점식이므로 대화식 프로세스에는 부적합
        - 장기 실행 프로세스가 뒤의 프로세스를 모두 지연시켜 평균 대기시간이 길어져 최악의 대기시간이 됨
        - 긴 프로세스가 실행되는 동안 짧은 프로세스가 긴 대기시간으로 호위 효과가 발생

### 2. 최소작업 우선 스케줄링

- 각 작업의 프로세서 실행 시간을 이용하여 프로세서가 사용 가능할 때 실행 시간이 가장 짧은 작업에 할당하는 방법

- 두 프로세스가 아래 그림 같은 순서로 프로세서 실행 시간이 동일하다면 선입선처리 스케줄링을 적용

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-19.jpg" alt="그림 6-19" style="border:1px; border-style: solid; zoom:100%;"/>

- 장점과 단점
    
    - 장점
        - 항상 실행 시간이 짧은 작업을 신속하게 실행하므로 평균 대기시간이 가장 짧음
    
    - 단점
        - 초기의 긴 작업을 짧은 작업을 종료할 때까지 대기시켜 기아가 발생
        - 기본적으로 짧은 작업이 항상 실행되도록 설정하므로 불공정한 작업을 실행
        - 실행 시간을 예측하기가 어려워 실용적이지 못함

### 3. 우선순위 스케줄링

- 일반적인 우선순위 스케줄링의 특별한 경우로 볼 수 있음

- 우선순위 스케줄링은 아래 그림 같이 프로세스가 준비 큐에 도착하면. 도착한 프로세스의 우선순위와 현재 실행 중인 프로세스의 우선순위를 비교하여 우선순위가 가장 높은 프로세스에 프로세서를 할당

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-24.jpg" alt="그림 6-24" style="border:1px; border-style: solid; zoom:100%;"/>

- 우선순위가 동일한 프로세스들은 선입선처리 순서로 스케줄링

- 우선순위를 내부적 또는 외부적으로 정의 가능

- 우선순위 스케줄링도 선점 및 비선점 가능

- 우선순위 스케줄링 알고리즘의 주요 문제는 무한 정지와 기아
    - 실행 준비는 했으나 우선 순위가 높은 프로세스가 계속 들어오면 우선순위가 낮은 프로세스는 무한정 기다림
    - 이를 해결할 수 있는 방법이 **에이징**

    - 에이징
        - 시스템에서 오래 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 방법
        - 시간이 지나면 점차 프로세스의 우선순위가 높아짐

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-27.jpg" alt="그림 6-27" style="border:1px; border-style: solid; zoom:100%;"/>

- 장점과 단점

    - 장점
        - 각 프로세스의 상대적 중요성을 정확히 정의할 수 있음
        - 다양한 반응으로 실시간 시스템에 사용 가능

    - 단점
        - 높은 우선순위 프로세스가 프로세서를 많이 사용하면 우선순위가 낮은 프로세스는 무한정 연기되는 기아가 발생


### 4. 라운드 로빈 스케줄링

- 라운드 로빈 스케줄링은 특별히 시분할 시스템을 위해 설계

- 이 스케줄링은 작은 단위의 시간인 규정 시간량 또는 시간 할당량을 정의

- 준비 큐를 순환 큐로 설계하여 스케줄러가 준비 큐를 돌아가면서 한 번에 한 프로세스에 정의된 규정 시간량만큼 프로세서를 제공

- 준비 큐는 FIFO 큐로 되어 있어 아래 그림과 같이 새로운 프로세스를 추가할 때는 준비 큐의 맨 뒤에 붙임

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-28.jpg" alt="그림 6-28" style="border:1px; border-style: solid; zoom:100%;"/>

- 스케줄러는 준비 큐의 앞부분에 있는 프로세스에 프로세서를 할당

- 규정된 시간량이 지나 인터럽트가 발생하도록 하면 다음 두가지 경우가 가능

    - 첫째, 규정 시간 안에 작업을 마친 경우 프로세서가 자유로워져 준비 큐에 있는 다음 프로세스를 진행
    - 둘째, 현재 실행 중인 프로세스의 실행 시간이 규정 시간량보다 긴 경우 운영체제가 인터럽트
        - 중단된 프로세스의 레지스터들은 프로세스의 프로세스 제어 블록에 저장
        - 프로세스는 준비 큐의 마지막 위치에 입력, 그리고 스케줄러는 준비 큐에서 다음 작업을 가져와 실행

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-29.jpg" alt="그림 6-29" style="border:1px; border-style: solid; zoom:100%;"/>

- 장점과 단점

    - 장점
        - 모든 프로세스가 프로세서의 동일한 점유율과 제한된 대기시간으로 공정하며 기아가 발생하지 않음
        - 실행큐에 프로세스 수를 알고 있을 때 구현이 용이
        - 강한 상호작용과 프로세스의 짧은 응답시간, 특히 프로세스 최악의 응답시간을 알 수 있음
        - 작업 길이가 다양할 때는 이전 작업을 마친 후보다 규정 시간량을 마치고 다음 작업으로 이동하기 때문에 평균 대기시간이 선입선처리와 최소작업 우선 스케줄링보다 적음

    - 단점
        - 성능은 규정 시간량의 길이에 따라 달라지므로 작업이 비슷한 길이가 좋음
            - 너무 길면 선입선처리로 변하고 너무 짧으면 많은 문맥 교환으로 비용 부담이 큼
        - 하드웨어 타이머가 필요
        -미완성 작업은 각 규정 시간량을 마친 후 프로세서를 기다리므로 평균 처리 시간이 높음

### 5. 다단계 큐 스케줄링

- 각 작업을 서로 다른 묶음으로 분류할 수 있을 때 사용
    - 포그라운드 태스크(foreground task), 백그라운드 태스크(background task)
- 두 유형의 요청 반응 시간은 다름, 서로 다르게 스케줄링 필요

- 준비 상태 큐를 여러 단계로 분할

- 작업에 따라 메모리의 크기나 프로세스를 특정 큐에 지정

- 각 큐는 독자적인 스케줄링을 가짐
    - 예) 포그라운드 -> 라운드 로빈 스케줄링
    - 예) 백그라운드 -> 선입선처리 스케줄링
    - 큐 사이도 스케줄링을 해야하는 데, 이것은 고정된 선점 우선순위 스케줄링

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-34.jpg" alt="그림 6-34" style="border:1px; border-style: solid; zoom:100%;"/>

- 각 큐는 순서대로 절대적인 우선순위를 가짐

- 우선순위가 높은 큐가 모두 비어 있기 전에는 낮은 우선순위 큐에 있는 프로세스를 실행할 수 없음

- 큐 사이에 시간을 나눠 사용할 수도 있음
    - 각 큐는 프로세서 시간의 일정량을 받아서 큐에 있는 프로세스들을 스케줄링할 수 있음
    - 예) 포그라운드 -> 프로세서 시간의 80%
    - 예) 백그라운드 -> 프로세서 시간의 20%

### 6. 다단계 피드백 큐 스케줄링

- 작업이 시스템에 들어가면 한 큐에서만 고정되어 실행

- 스케줄링 부담이 적다는 장점이 있으나 융통성이 떨어진다는 단점

- 이때는 프로세서 버스트의 특성에 따라 분리
    - 예) 프로세서 실행 시간이 너무 길면 작업을 낮은 단계 큐로

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-35.jpg" alt="그림 6-35" style="border:1px; border-style: solid; zoom:100%;"/>

- 프로세서 버스트 시간이 작은 프로세스에 높은 우선순위를 주어 일찍 종료시키고 다음 입출력 버스트를 실행하도록 함

- 프로세스가 더 낮은 수준의 큐로 옮겨 갈 때 스케줄러는 해당 프로세스의 규정 시간량을 증가 시켜 프로세스가 더 오래 작업할 수 있도록 함

- 다단계 피드백 큐 스케줄링은 다음에 따라 정의됨
    - 큐의 수
    - 각 큥에 대한 스케줄링
    - 작업을 좀 더 높은 우선순위의 큐로 격상시키는 시기를 결정하는 방법
    - 작업을 좀 더 낮은 우선순위의 큐로 격하시키는 시기를 결정하는 방법
    - 프로세스들이 어느 큐에 들어갈 것인지 결정하는 방법
    - 프로세스가 서비스를 받는 시기를 결정하는 방법

- 다단계 피드백 큐 스케줄링은 프로세서 스케줄링 중 가장 일반적

- 장점과 단점
    - 장점
        - 매우 유연하여 스케줄러를 특정 시스템에 맞게 구성
        - 자동으로 입출력 중심과 프로세서 중심 프로세스를 분류
        - 적응성이 좋아 프로세스의 사전 정보가 없어도 최소작업 우선 스케줄링의 효과를 보여줌
    - 단점
        - 설계와 구현이 매우 복잡


### 7. HRN 스케줄링

- 최소 작업 우선 스케줄링의 약점이었던 긴 작업과 짧은 작업 간의 지나친 불평 등을 어느 정도 보완한 스케줄링

- 비선점 스케줄링이며 우선순위 스케줄링의 또 다른 예로, 선입선처리 스케줄링과 최소작업 우선 스케줄링의 약점을 해결하고 함

- 각 작업의 우선순위를 아래 그림과 같이 작업이 서비스를 받을 시간 뿐만 아니라 서비스를 기다린 시간의 함수로 나타냄

- 한 작업이 프로세서를 차지하면 작업을 종료할 때까지 실행

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-38.jpg" alt="그림 6-38" style="border:1px; border-style: solid; zoom:100%;"/>

- 서비스를 받을 시간이 분모에 있으므로 이 시간이 짧을 수록 우선 순위가 높음
- 대기한 시간이 분자에 있으므로 이 시간이 긴 작업일수록 우선순위가 높아 시스템의 반응시간은 아래 그림과 같이 나타냄

<img width="500" src="..\img\그림으로 배우는 구조와 원리 운영체제\Chapter6\그림 6-39.jpg" alt="그림 6-39" style="border:1px; border-style: solid; zoom:100%;"/>

- 장점과 단점
    - 장점
        - 자원을 효율적으로 활용
        - 기아가 발생하지 않음
    - 단점
        - 오버헤드가 높을 수 있음


### 8. 다중 프로세서 스케줄링]

- 프로세서가 여러 개면 스케줄링 문제가 복잡

- 문제는 프로세서들의 형태가 다를 수 있음

- 각 프로세서에 독자적인 큐와 스케줄링이 있으므로 이것이 다르면 가능한 서택의 경우 수가 상대적으로 제한됨

- 또 하나의 시스템에 종류가 같은 프로세서가 여러 개이면 부하 공유가 발생

- 이는 각 프로세서에 서로 독립된 준비 큐를 제공하도록 하여 방지

- 프로세서를 모든 프로세서에 한 번만 할당하기 때문에 스케줄링 오버헤드가 적다는 장점

- 하지만 어떤 프로세서는 큐가 비어 아무 일도 하지 않는 반면, 다른 프로세서는 처리할 작업이 가득 차 매우 바쁠 수 있는 단점

- 이런 현상 방지를 위해 공동의 준비 큐를 사용해 모든 작업이 이용 가능한 프로세서 큐로 가도록 스케줄링해야 함

- 그러면 프로세스가 메모리에 적재되는 동안 다른 프로세서에서 작업을 실행할 수 있음

- 여기서 두 가지 스케줄링 방법이 사용

    - 첫째
        - 프로세서 자신이 스스로 스케줄링
        - 각 프로세서는 공통의 준비 상태 큐에서 실행할 프로세스 하나를 선택
        - 프로세서 2개가 같은 프로세스를 선택하지 않도록 함
        - 프로세스가 큐에서 누락되지 않도록 함

    - 둘째
        - 비대칭 다중 처리로 한 프로세서를 다른 모든 프로세서의 스케줄러로 지정
        - 주종(주인/하인) 구조를 보임
        - 이구조에서 운영체제의 핵심 커널 기능들은 특정 프로세서에서 수행
        - 다른 프로세서들은 사용자 프로세스만 수행
        - 주 프로세서는 프로세스들을 스케줄링하여 프로세스를 활성화
        - 종 프로세스에 입출력 호출 등의 서비스가 필요하면 주 프로세서에 요청하여 서비스의 처리를 기다림


### 9. 스레드 스케줄링

- 스레드를 이용하여 응용 프로그램을 동일한 주소 공간에서 동시에 실행하고 협동하는 스레드들로 구현

- 스레드 문맥 교환은 프로세스 문맥 교환보다 오버헤드가 적어 응용 프로그램 하나의 여러 스레드를 동시에 다른 프로세서에서 실행해 성능을 현저하게 향상 가능

- 다음은 다중 프로세서 스레드 스케줄링과 프로세서 할당에 대한 일반적인 방법

    - 부하 공유
        - 프로세서를 특정 프로세스 하나에 할당하지 않고 전역 큐에서 프로세서를 유지

        - 쉬고 있는 프로세스는 전역 큐에서 스레드 한 개를 선택

    - 갱 스케줄링
        - 관련된 스레드의 집합을 일대일 대응 원칙에 따라 프로세서 집합에서 동시에 실행할 수 있도록 하는 스케줄링 방법

        - 단일 프로세스에 속한 스레드들을 동시에 스케줄링

    - 전용 프로세서 할당
        - 전용 프로세서 할당은 부하 공유와는 반대로 스레드들을 실행 전담 프로세서에 할당하여 정의된 스케줄링을 제공하는 방법

    - 동적 스케줄링
        - 프로세스의 스레드 수를 동적으로 변경하여 운영체제가 시스템 이용률을 높일 수 있도록 부하 조절을 허용한 방법

- 갱 스케줄링과 전용 프로세서 할당은 프로세서 단편화 문제를 회피하는 방법

- 전용 프로세서 할당은 갱 스케줄링과 같이 프로세서를 효율적으로 할당하여 스케줄링 문제를 해결


