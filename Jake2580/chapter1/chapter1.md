# 컴퓨터 하드웨어의 구성

<br>

- 컴퓨터 시스템
	- 데이터를 처리하는 하드웨어와 작업을 지시하는 소프트웨어로 구성됨
	- 하드웨어는 데이터를 처리하는 물리적인 기계장치
	- 소프트웨어는 어떤 작업을 지시하는 명령어로 작성한 프로그램

<br>

- 운영체제(Operating System)는 컴퓨터의 하드웨어를 관리하는 소프트웨어
	- 운영체제를 이해하려면 먼저 하드웨어를 알아야함

<br>

컴퓨터 하드웨어는 크게 프로세서, 메모리 기억장치, 주변장치로 구성되어 있으며<br>이들은 시스템버스로 연결된다.

<br>

![그림 1-1](/Jake2580/chapter1/image/p1.png)

[그림 1-1] 컴퓨터 하드웨어의 구성

<br>

# 프로세서

<br>


- 프로세서(processor)는 하드웨어에 부착한 모든 장치의 동작을 제어하고 명령을 실행함
	
	- 중앙처리장치(Central Processing Unit)라고도 함

<br>

프로세서는 연산장치와 제어장치, 레지스터로 구성되고, 이들은 내부 버스로 연결된다.

<br>

![그림 1-2](/Jake2580/chapter1/image/p2.png)

[그림 1-2] 프로세서의 구성

<br>

- 레지스터(Register)

	- 프로세서의 종류가 다양한 것처럼 레지스터의 종류와 크기가 다양함
	- 용도에 따라 전용 레지스터와 범용 레지스터로 구분할 수 있음
	- 사용자가 정보를 변경할 수 있는지에 따라 사용자 [가시, 불가시] 레지스터로 구분할 수 있음
		- 사용자 가시 레지스터는 사용자가 OS 또는 프로그램으로 정보를 변경할 수  있는 레지스터
	- 저장하는 정보의 종류에 따라 [데이터, 주소, 상태] 레지스터 등으로 세분화할 수 있음 

<br>

[표 1-1] 사용자 가시 레지스터

| 종류            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 데이터 레지스터 | 함수 연산에 필요한 데이터를 저장한다.<br />값, 문자 등을 저장하므로 산술 연산이나 논리 연산에 사용하며,<br />연산 결과로는 플래그 값을 저장한다. |
| 주소 레지스터   | 주소나 유효 주소를 계산하는 데 필요한 주소의 일부분을 저장한다.<br />주소 레지스터에 저장한 값(값 데이터)을 사용하여 산술 연산을 할 수 있다. |

<br>

[주소 레지스터]

| 종류                 | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| 기준 주소 레지스터   | 프로그램을 실행할 때 사용하는 기준 주소 값을 저장한다.<br />기준 주소는 하나의 프로그램이나 일부처럼 서로 관련 있는 정보를 저장하며,<br />연속된 저장 공간을 지정하는 데 참조할 수 있는 주소이다.<br />따라서 기준 주소 레지스터는 페이지나 세그먼트처럼 블록화된 정보에 접근하는 데 사용한다. |
| 인덱스 레지스터      | 유효 주소를 계산한은 데 사용하는 주소 정보를 저장한다.       |
| 스택 포인터 레지스터 | 메모리에 프로세서 스택을 구현하는데 사용한다.<br />많은 프로세서와 주소 레지스터를 데이터 스택 포인터와 큐 포인터로 사용한다.<br />보통 반환 주소, 프로세서 상태 정보, 서브루틴의 임시 변수를 저장한다. |

<br>

[표 1-2] 사용자 불가시 레지스터

| 종류                 | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| 프로그램 카운터      | 다음에 실행할 명령어의 주소를 보관하는 레지스터이다.<br />계수기로 되어 있어 실행할 명령어를 메모리에서 읽으면<br>명령어의 길이만큼 증가하여 다음 명령어를 가리키며,<br>분기 명령어는 목적 주소로 갱신할 수 있다. |
| 명령어 레지스터      | 현재 실행하는 명령어를 보관하는 레지스터이다.                |
| 누산기               | 데이터를 일시적으로 저장하는 레지스터이다.                   |
| 메모리 주소 레지스터 | 프로세서가 참조하려는 데이터의 주소를 명시하여<br>메모리에 접근하는 버퍼 레지스터이다. |
| 메모리 버퍼 레지스터 | 프로세서가 메모리에서 읽거나<br>메모리에 저장할 데이터 자체를 보관하는 버퍼 레지스터이다.<br />메모리 데이터 레지스터(Memory Data Register)라고도 한다. |

<br>![그림 1-3](/Jake2580/chapter1/image/p3.png)

[그림 1-3] 프로세서의 기본 레지스터

<br>

# 메모리

<br>

메모리는 컴퓨터 성능과 밀접한데,<br>사용자는 당연히 크고 빠르며 비용이 절며한 메모리를 요구한다.<br>하지만 속도가 빠른 메모리는 가격이 비싸서 보통은 메모리 계층 구조를 구성하여<br>비용, 속도, 용량, 접근시간 등을 상호 보완한다.

<br>

속도는 느리나<br>용량이 큰 보조기억장치부터 속도는 빠르나<br>용량이 작은 작은 레지스터까지 메모리의 종류는 다양하다.

<br>![그림 1-4](/Jake2580/chapter1/image/p4.png)

[그림 1-4] 메모리 계층 구조

<br>

메모리 계층구조는 메인 메모리를 중심으로 아래에는<br>대용량의 자기디스크, 이동이 편리한 광디스크, 파일을 저장하는 속도가 느린 자기테이프가 있다.<br>그리고 메인 메모리 위에는 메인  메모리와 프로세서의 속도 차이를 보완하는 캐시가 있다.<br>최상위에는 프로세서가 사용한 데이터를 보관하는 가장 빠른 레지스터가 있다.

<br>

- 레지스터
	- 프로세서 내부에 있으며, 프로세서가 사용할 데이터를 보관하는 가장 빠른 메모리

<br>

- 메인메모리
	- 프로세서 외부에 있으며,<br>프로세서에서 즉각적으로 수행할 프로그램과 데이터를 저장하거나<br>프로세서에서 처리한 결과를 메인 메모리에 저장함
	- 입출력장치도 메인 메모리에서 데이터를 받거나 저장함
	- 주기억장치 또는 1차 기억장치라고도 함
	- 저장 밀도가 높고 가격이 싼 DRAM을 많이 사용함

<br>

![그림 1-5](/Jake2580/chapter1/image/p5.png)

[그림 1-5] 메인 메모리의 역할 1

<br>

메인 메모리는 다수의 셀로 구성되며, 각 셀은 비트로 구성된다.<br>셀이 N비트이면 셀에 2ⁿ 값을 저장할 수 있다.<br>메인 메모리에 데이터를 저장할 때는 셀 한 개나 여러 개에 나눠서 자장한다.<br>셀은 주소로 참조하는데,  n비트일 경우 주소 범위는 0 ~ 2ⁿ - 1 이다.

<br>

![그림 1-6](/Jake2580/chapter1/image/p6.png)

[그림 1-6] 메인 메모리의 주소 지정

<br>

이처럼 컴퓨터에 주어진 주소를 물리적 주소라고 하는데,<br>프로그래머는 물리적 주소 대신 수식이나 변수를 사용한다.<br>그리고 컴파일러가 프로그램을 기게 명령어로 변환할 때<br>변수와 명령어에 주소를 할당하는데,<br>이 주소를 논리적 주소(가상 주소, 프로그램 주소)라고 한다.

<br>

논리적 주소는 별도의 주소 공간에 나타나고<br>컴파일로 논리적 주소를 물리적 주소로 변환하는데,<br>이 과정을 매핑(mapping) 또는 메모리 맵(memory map)이라고 한다.

<br>

![그림 1-7](/Jake2580/chapter1/image/p7.png)

[그림 1-7] 메모리 배핑

<br>

운영체제는 가상 메모리(virtual memory) 방법을 사용하여 메인 메모리의 유효 크기를 늘릴 수 있는데,<br>이 내용은 다른 챕터에서 자세히 다룰 예정이다.

<br>

![그림 1-8](/Jake2580/chapter1/image/p8.png)

[그림 1-8] 메모리 접근시간과 메모리 사이클 시간

<br>

- 메모리 속도는 메모리 접근시간과 메모리 사이클 시간으로 표현할 수 있다.
	- 메모리 접근시간은 명령이 발생한 후 목표 주소를 검색하여 데이터 쓰기(읽기)를 시작할 때까지 걸린 시간
	- 메모리 사이클 시간은 두 번의 연속적인 메모리 동작 사이에 필요한 최소 지연시간

<br>

보통 사이클 시간이 접근시간보다 약간 길며, 메모리의 세부 구현 방법에 따라 다르다.

<br>![그림 1-9](/Jake2580/chapter1/image/p9.png)

[그림 1-9] 메인 메모리의 역할 2 : 캐시 추가

<br>

메인 메모리는 프로세서와 보조기억장치 사이에 있으며,<br>여기서 발생하는 디스크 입출력 병목 현상을 해결하는 역할도 한다.

<br>

그런데 프로세서와 메인 메모리 간에 속도 차이가 나면서<br>메인 메모리의 부담을 줄이려고 프로세서 내부나 외부에 캐시를 구현하기도 한다.

<br>

# 캐시

<br>

- 캐시
	- 프로세서 내부나 외부에 있음
	- 처리 속도가 빠른 프로세서와 상대적으로 느린 메인 메모리의 속도 차이를 보완하는 고속 버퍼

<br>![그림 1-10](/Jake2580/chapter1/image/p10.png)

[그림 1-10] 캐시의 역할

<br>

메인 메모리에서 데이터를 블록 단위로 가져와 프로세서에 워드 단위로 전달하여 속도를 높인다.<br>그리고 데이터가 이동하는 통로(대역폭)을 확대하여 프로세서와 메모리의 속도 차이를 줄인다.

<br>![그림 1-11](/Jake2580/chapter1/image/p11.png)

[그림 1-11] 캐시의 기본 동작

<br>

캐시의 동작을 좀 더 구체적으로 살펴보면,<br>캐시는 주소 영역을 한 번 읽어 들일 수 있는 크기로 나눈 후<br>각 블록에 번호를 부여하여 이 번호를 태그로 저장한다.

<br>

프로세서는 메인 메모리에 접근하기 전에 캐시에 해당 주소의 자료가 있는지 먼저 확인한다.<br>이를 위해 접근하려는 주소 24비트(0001 0011 0011 1001 1100) 중<br>태그에 해당하는 처음 22비트(00 0101 1000 1100 1110 0111)를<br>캐시의 모든 라인과 비교하여 일치하는 라인을 찾는다.

<br>

일치하는 라인이 있으면, 주소의 나머지 2비트(00)를 이용하여<br>데이터 라인의 4개(00, 01, 10, 11) 바이트 중 해당하는 바이트를 가져온다.

<br>

캐시의 성능은 작은 용량의 캐시에 프로세서가 이후 참조할 정보가 얼마나 들어 있느냐로 좌우되며<br>프로세서가 참조하려는 정보가 있을 때는 캐시 적중(cache hit)이라 하고,<br>반대로 없을 때는 캐시 실패(cache miss)라고 한다.

<br>

이때 블록의 크기는 캐시의 성능으로 좌우되는데, 실제 프로그램을 실행할 때 참조한 메모리에 대한<br>공간적 지역성(국부성)과 시간적 지역성(국부성)이 있기 때문이다.

<br>

공간적 지역성(spatial locality)은<br>대부분의 프로그램이 참조한 주소와 인접한 주소의 내용을 다시 참조하는 특성이고,

시간적 지역성(temporal locality)은<br>한 번 참조한 주소를 곧 다시 참조하는 특성이다.

<br>

- 프로그램이 명령어를 순차적으로 실행하는 경항이 있어서 명령어가 특정 지역 메모리에 인접해 있음
- 순환(단일 순환, 중첩 순환 등) 때문에 프로그램에 반복하더라도 메모리는 일부 영역만 참조함
- 대부분의 컴파일러를 메모리에 인접한 블록에 배열로 저장한다.
	- 따라서 프로그램이 배열 원소에 순차적으로 자주 접근하여 지역적인 배열 접근 경향이 있음

<br>

지역성은 블록이 크면 캐시의 히트율이 올라갈 수 있음을 의미하지만,<br>블록이 커지면 이에 따른 전송 부담과 캐시 데이터 교체 작업이 자주 일어나므로<br>블록 크기를 무작정 늘릴 수 는 없다.

<br>

# 보조기억장치

<br>

주변장치 중 프로그램과 데이터를 저장하는 하드웨어로,

2차 기억장치 또는 외부기억장치라고도 한다.

ex) 자기디스크, 광디스크, 자기테이프 등이 있다.

<br>

# 시스템 버스

<br>

- 시스템 버스는 하드웨어를 물리적으로 연결하여 서로 데이터를 주고받을 수 있게 하는 통로
	- 컴퓨터 내부의 다양한 신호를 시스템 버스로 전달
		- 데이터 입출력 신호
		- 프로세서 상태 신호
		- 인터럽트 요구와 허가 신호
		- 클록(clock) 신호

<br>

시스템 버스는 기능에 따라서 [데이터, 주소 제어] 버스로 구분한다.

<br>![그림 1-12](/Jake2580/chapter1/image/p12.png)

[그림 1-12] 시스템 버스

<br>

[표 1-3] 시스템 버스의 종류

| 종류        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| 데이터 버스 | 프로세서와 메인 메모리, 주변장치 사이에서 데이터를 전송한다.<br />데이터 버스를 구성하는 배선 수는<br/>프로세서가 한 번에 전송할 수 있는 비트 수를 결정하는데,<br />이를 **워드**라고 한다. |
| 주소 버스   | 프로세서가 시스템의 구성 요소를 식별하는 주소 정보를 전송한다.<br />주소 버스를 구성하는 배선 수는<br/>프로세서와 접속할 수 있는 메인 메모리의 최대 용량을 결정한다. |
| 제어 버스   | 프로세서가 시스템의 구성 요소를 제어하는 데 사용한다.<br />제어 신호로 연산장치의 연산 종류와 메인 메모리의 읽기나 쓰기 동작을 결정한다. |

<br>

# 주변장치

<br>

주변장치는 프로세서와 메인 메모리를 제외한 나머지 하드웨어 구성 요소이다.<br>단순히 입출력장치라고도 하나, 크게 입력장치, 출력장치, 저장장치로 구분한다.

<br>

- 입력장치 : 컴퓨터에서 처리할 데이터를 외부에서 입력하는 장치이다.
- 출력장치 : 입력장치와 반대로 컴퓨터에서 처리한 데이터를 외부로 보내는 장치이다.
- 저장장치 : 메인 메모리와 달리 거의 영구적으로 데이터를 저장하는 장치이다.
	- 데이터를 입력하여 저장하며, 저장한 데이터를 출력하는 공간이므르 입출력장치에 포함하기도 한다.

<br>

# 컴퓨터 시스템의 동작

<br>

- 컴퓨터 시스템의 동작 순서
	- 입력장치로 정보를 입력받아 메모리에 저장한다.
	- 메모리에 저장한 정보를 프로그램 제어에 따라 인출하여 연산장치에서 처리한다.
	- 처리한 정보를 출력장치에 표시하거나 보조기억장치에 저장한다.

<br>

- 입력장치로 컴퓨터에 유입되는 정보는 명령어와 데이터로 분류한다.
	- 명령어는 실행할 산술 논리 연산의 동작을 명시하는 문장으로,<br>어떤 작업을 수행하는 명령어 집합이 프로그램이다.
	- 프로그램은 컴파일러 등을 이용하여 0과 1로 이진화된 기계 명령어로 변환해야 컴퓨터가 이해할 수 있다.

<br>

# 명령어의 구조

<br>

- 명령어의 구조

	프로세서가 실행할 연산인 연산 부호와 명령어가 처리할 데이터와<br>데이터를 저장한 레지스터나 메모리 주소인 피연산자로 구성


<br>

![그림 1-13](/Jake2580/chapter1/image/p13.png)

[그림 1-13] 명령어의 기본 구조

<br>

명령어는 프로세서에 따라 고정 길이나 가변 길이를 구성한다.<br>연산 부호는 특별한 경우가 아니면 한 개이나 피연산자는 여러 개일 수 있다.

<br>

- 연산 부호(OPcode, Opertion Code)

  - 프로세서가 실행할 동작인 연산을 지정

  	- 산술 연산, 논리 연산, 시프트, 보수 등 연산을 정의
  	- 연산 부호가 n비트이면 최대 2ⁿ개 연산이 가능


<br>

- 피연산자(operand)
	- 연산할 데이터 정보를 저장
	- 데이터는 레지스터나 메모리, 가상기억장치, 입출력장치 등에 위치할 수 있음
		- 보통 데이터 자체보다는 데이터의 위치를 저장함

<br>![그림 1-14](/Jake2580/chapter1/image/p14.png)

[그림 1-14] 소스 피연산자와 목적지 피연산자

<br>

가장 일반적인 명령어 구조이며 여기서는 피연산자가 2개로<br>하나는 **소스 피연산자(source operand)**이고,<br>다른 하나는 **목적지 피연산자(destination operand)**이다.

<br>![그림 1-15](/Jake2580/chapter1/image/p15.png)

[그림 1-15] 메인 메모리에 저장된 명령어 예시

<br>

명령어는 실행 전에 메인 메모리에 저장하며,<br>한 번에 하나씩 프로세서에 순차적으로 전송하여 해석 및 실행한다.

<br>

명령어는 피연산자를 여러 개 포함할 수도 있다.

<br>

피연산자 수에 따라<br>0 - 주소 명령어<br>1 - 주소 명령어<br>2 - 주소 명령어<br>3 - 주소 명령어 등으로 구분한다.

<br>

- 누산기
	- 메모리에서 읽은 피연산자를 레지스터에 저장된 데이터와 연산할 때 사용하는 레지스터
	- 프로그램의 명령어 수행 중에 산술 및 논리 연산의 결과를 일시적으로 저장함

<br>![그림 1-16](/Jake2580/chapter1/image/p16.png)

[그림 1-16] 모드 비트를 추가한 명령어 형식

<br>

명령어에 피연산자의 위치를 명시하는 방법(직접 주소 또는 간접 주소)을<br>나타내는 모드 비트(mode bit) I를 추가하거나,<br>다음 명령어의 위치를 나타내는 주소를 추가할 수 도 있다.

<br>

- 직접 주소(direct address)

  피연산자에 데이터가 있는 레지스터나 메모리 주소를 지정

<br>

- 간접 주소(indirect address)

	데이터가 있는 레지스터나 메모리 주소 정보를 지정하면 간접 주소

<br>![그림 1-17](/Jake2580/chapter1/image/p17.png)

[그림 1-17] 직접 주소와 간접 주소를 사용한 명령어 예시

- 모드가 1비트, 연산 부호가 3비트, 피연산자가 6비트인 명령어
	- 모드
		- 0 - 직접 주소
		- 1 - 간접 주소

<br>

(a) 직접 주소 명령어

​	001001이므로 9번지에서 데이터를 찾는다.

<br>

(b) 간접 주소 명령어

​	001001에 해당하는 9번지의 내용이 실제 데이터를 저장하고 있는 주소이다.

​	그러므로 9번지의 001110, 즉 14번지에서 데이터를 찾는다.

​	이처럼 간접 주소는 데이터의 주소를 읽을 때 한 번, 데이터를 읽을 때 한 번 총 두 번 메모리를 참조한다.

<br>

# 명령어의 실행

<br>![그림 1-18](/Jake2580/chapter1/image/p18.png)

[그림 1-18] 명령어 실행 과정

<br>

명령어는 다음 과정을 거쳐 실행한다.

<br>

프로세서의 제어장치가 명령어를 실행한다.<br>프로세서는 메모리에서 명령어를 한 번에 하나씩 인출하고 해석하여 연산한다.<br>명령어를 인출하여 연산 완료한 시점까지를 인출-해석-실행 사이클 또는 인출-실행 사이클이라고 한다.

<br>

간단히 명령어 실행 사이클(명령어 실행 주기)이라고도 한다.

<br>

![그림 1-19](/Jake2580/chapter1/image/p19.png)

[그림 1-19] 명령어 실행 사이클

<br>

명령어 실행 사이클은 (a)와 같이 명령어의 인출과 실행을 반복하는데,<br>이는 가장 일반적인 명령어 사이클이다.

<br>

메모리 간접 주소 지정 방법은 (b)와 같이 실행 사이클을 시작하기 앞서<br>그 데이터의 실제 주소를 기억장치에서 읽어 오는 간접 사이클을 사용하기도 한다.

<br>

그리고 인터럽트를 처리하려고 인터럽트 사이클을 사용하기도 한다.

<br>

# 인출 사이클

<br>![그림 1-20](/Jake2580/chapter1/image/p20.png)

[그림 1-20] 인출 사이클 과정

<br>

- 인출 사이클
	- 명령어 실행 사이클의 첫 번째 단계
	- 메모리에서 명령어를 읽어 명령어 레지스터에 저장하고,<br>다음 명령어를 실행하기 위해서 PC를 증가시킴
	- 인출 사이클에 소요되는 시간을 명령어 인출 시간이라고 하며,<br>이 사이클에서 시간에 따른 세부 동작은 [그림 1-20]과 같음

<br>

# 실행 사이클

<br>

- 실행 사이클
	- 인출한 명령어를 해독하고<br>그 결과에 따라 제어 신호를 발생시켜 명령어를 실행함
	- 이 단계에서 소비되는 시간을 **실행 시간**이라고 함

<br>

# 간접 사이클

<br>

- 간접 사이클
	- 직접 주소 지정 방법을 사용하는 실행 사이클
		- 명령어를 즉시 수행
	- 간접 주소 지정 방법을 사용하는 실행 사이클
		- 명령어를 수행하기 전에<br>실제 데이터가 저장된 주기억장치의 주소인<br>유효 주소를 한 번 더 읽음

<br>![그림 1-21](/Jake2580/chapter1/image/p21.png)

[그림 1-21] 간접 사이클 과정

<br>

간접 사이클(indirect cycle)에서 시간에 따른 세부 동작

<br>

| 시간 | 레지스터 동작     | 설명                                                         |
| ---- | ----------------- | ------------------------------------------------------------ |
| 1    | IR(addr) → MAR    | IR에 저장된 명령어의 피연산자(주소부)를 MAR에 전달한다.      |
| 2    | Memory(MAR) → MBR | MAR에 저장된 주소에 해당하는 메모리 위치에서<br/>데이터를 인출한 후 이 데이터를 MBR에 저장한다.<br />이때 제어장치는 메모리에 저장된 내용을 읽도록 제어 신호를 발생시킨다. |
| 3    | MBR → IR(addr)    | MBR에 저장된 내용을 IR에 전달한다.                           |

<br>

IR : 명령어 레지스터<br>MAR : 메모리 주소 레지스터<br>MBR : 메모리 버퍼 레지스터

<br>

# 인터럽트 사이클

<br>

- 인터럽트
	- 프로세서가 프로그램을 수행하는 동안<br>컴퓨터 시스템의 내부나 외부에서 발생하는 예기치 못한 사건을 의미
	- 프로세서는 실행 사이클을 완료한 후 인터럽트 요구가 있는지 검사
		- 인터럽트 요구가 없으면 다음 명령어를 인출함
		- 인터럽트 요구가 있으면 현재 수행 중인 프로그램의 주소(PC) 값을<br>스택이나 메모리의 0번지와 같은 특정 장소에 저장하고<br>PC에는 인터럽트 처리 루틴의 시작 주소를 저장해 두었다가<br>인터럽트 처리를 완료하면 중단된 프로그램으로 복귀하여 계속 수행함

<br>![그림 1-22](/Jake2580/chapter1/image/p22.png)

[그림 1-22] 인터럽트 사이클 과정

<br>

인터럽트 사이클(interrupt)의 세부 동작

| 시간 | 레지스터 동작           | 설명                                                         |
| ---- | ----------------------- | ------------------------------------------------------------ |
| 1    | PC → MBR                | 프로그램 카운터의 내용을 MBR에 저장한다.                     |
| 2    | IntRoutine_Address → PC | 인터럽트 루틴 주소를 프로그램 카운터에 저장한다.             |
| 2    | Save_Address → MAR      | 프로그램 카운터에 저장된 인터럽트 루틴 주소를 MAR에 저장한다. |
| 3    | MBR → Memory(MAR)       | MBR의 주소에 있는 내용을 지시된 메모리 셀로 이동한다.        |

<br>

PC : 프로그램 카운터

MAR : 메모리 주소 레지스터

MBR : 메모리 버퍼 레지스터

<br>

# 인터럽트 명령어

<br>

- 인터럽트
	- 현재 실행 중인 프로그램을 중단하고 다른 프로그램의 실행을 요구하는 명령어
	- 시스템의 처리 효율을 향상
	- 프로그램이 실행 순서를 바꿔 가면서 처리하여 다중 프로그래밍에 사용
	- 컴퓨터에 설치된 I/O 장치나 프로그램 등에서 프로세서로 보내는 하드웨어 신호
	- 이 신호를 받은 프로그램은 실행을 중단하고 다른 프로그램을 실행
		- 단일 프로세서의 컴퓨터는 명령어를 한 번에 한개만 수행할 수 있지만,<br>인터럽트를 이용하면 중간에 다른 프로그램이나 명령어를 수행할 수 있음

<br>

특히 인터럽트는 아래와 같은 상황을 시스템이 적절히 처리하는 데 필요하다.

- 예상치 못한 사용자 입력
- 갑작스런 정전
- 컴퓨터 시스템에서 긴급 요청
- 잘못된 명령어 수행
- 입출력 작업 완료

<br>

인터럽트는 프로그램의 정상 실행을 일시 중단했다 다시 재개하는 과정이지만,<br>사용자가 별도로 인터럽트 조치를 할 필요가 없고 프로세서와 운영체제가 처리한다.

<br>

컴퓨터는 인터럽트를 외부장치의 동작과 자신의 동작을 조정하는 수단으로 사용함
> 다중 사용자 시스템에 키보드를 여러 개 연결하면<br>각 키보드에서 입력되는 문자를 구분하여 처리해야 함

<br>

- 인터럽트 전용 회선
	- 단일 회선
	  - 인터럽트 요청이 가능한 모든 장치를 공통의 단일 회선으로 프로세서에 연결하는 방법
	  - 회선 하나에 장치를 여러 개 연결하여 인터럽트를 요청한 장치를 판별하는 기능이 필요

	- 다중 회선
	  - 모든 장치를 서로 다른 고유의 회선으로 프로세서와 연결하는 방법
	  - 인터럽트를 요청한 장치를 바로 판별함

<br>![그림 1-23](/Jake2580/chapter1/image/p23.png)

[그림 1-23] 인터럽트 요청 회선 연결 방법

<br>

인터럽트 요청 신호가 발생하면 대부분의 컴퓨터는 정보를 단일 명령어로 저장할 수 있으므로<br>실행 중인 프로그램을 메모리에 저장하고, 인터럽트 처리 프로그램으로 분기한다.<br>그리고 인터럽트 처리 프로그램을 완료하면 인터럽트를 발생시킨 프로그램에 제어를 돌려준다.

<br>

![그림 1-24](/Jake2580/chapter1/image/p24.png)

[그림 1-24] 인터럽트 처리 과정

<br>

예르 들어, [그림 1-24]의 (a)와 같이 인터럽트가 도달하기 전에 프로그램 A를 실행한다고 하자.<br>프로그램 카운터는 현재 명령어를 가리킨다.<br>

<br>(b)에서 프로세서에 인터럽트 신호가 도달하여 현재 명령어를 종료한다.<br>레지스터의 모든 내용을 스택 영역(또는 프로세서 제어 블록)에 보낸다.<br>그리고 프로그램 카운터에는 인터럽트 처리 프로그램(프로그램 B)의 시작 위치를<br>저장하고 제어를 넘긴 프로그램 B를 실행한다.<br><br>(c)에서 인터럽트 처리 프로그램을 완료하면 스택 영역에 있던 내용을 레지스터에 다시 저장하여,<br>프로그램 A가 다시 시작하는 위치를 저장하고 중단했던 프로그램 A를 재실행한다.<br>

<br><br><br>

인터럽트는 서브루틴 호출과 매우 비슷하지만, 몇 가지 면에서 다르다.<br>보통 서브루틴은 자신을 호출한 프로글매이 요구한 기능을 수행하지만,<br>인터럽트 처리 프로그램은 인터럽트가 발생했을 때 실행 중인 프로그램과 관련이 없을 수도 있다.<br>그러므로 프로세서는 인터럽트 프로그램을 처리하기 전에 프로그램 카운터를 비롯해 중단된 프로그램으로<br>복귀하여 실행할 때 영향을 미치는 정보를 저장해야 한다.<br>특히 인터럽트가 발생할 때는 상태 코드(상태 워드)를 임시 기억장치에 저장해 두었다가<br>나중에 복귀했을 때 이를 다시 적재해야 한다.<br>그래야 원래 프로그램을 인터럽트의 영향을 받지 않고 다시 실행할 수 있다.

