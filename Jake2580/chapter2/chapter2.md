# 운영체제의 개념

<br>

![p](/Jake2580/chapter2/image/p2-1.png)

컴퓨터 시스템의 구성 요소와 운영체제

<br>

- 컴퓨터 시스템의 구성
	- 사용자
	- 소프트웨어
	  - 시스템 소프트웨어
	    - 컴퓨터 자원을 관리하고<br>응용 프로그램의 실행을 지원하여<br>컴퓨터를 제어하는 프로그램
	  - 유틸리티
	    - 응용 프로그램보다 작지만 컴퓨터의 여러 처리 과정을 보조하여<br>시스템을 유지하고 성능을 개선하는 프로그램으로 운영체제를 돕는 역할을 함
	    - 필요에 따라 사용자나 운영체제가 메모리 상주 프로그램으로 설치하기도 함
	  - 운영체제
	    - 컴퓨터 자원을 효율적으로 사용할 수 있도록 관리하고 조정하는 역할
	    - 사용자가 하드웨어에 접근할 수 있는 유일한 수단
	    - 응용 프로그램을 실행할 수 있는 기반 환경을 제공
	    - 컴퓨터를 편리하게 사용할 수 있도록 도와줌
	    - 하드웨어를 효율적으로 사용할 수 있도록 다양한 기능을 제공
	  - 응용 프로그램
	    - 어떤 문제를 해결하려고 사용자나 전문가가 만든 프로그램
	    - 특정 작업을 수행하려는 목적
	- 하드웨어
		- CPU(중앙처리장치)
		- 메모리
		- 주변장치

<br>

![p](/Jake2580/chapter2/image/p2-2.png)

운영체제의 역할

<br>

- 운영체제의 역할

	- 조정자

		- 다른 프로그램이 수행하는 특정 작업을 하는 것이 아니라<br>이 작업을 할 수 있는 환경만 제공함

			ex) 워드 프로세서 역할을 직접하는 것이 아니라 워드 프로세서가 제 기능을 할 수 있도록 도와줌

	- 자원 할당자, 관리자

		- 운영체제는 각 응용 프로그램에 필요한 자원을 할당하는 자원 할당자
		- 공정하고 효율적으로 운영하려고 자원을 할당하는 방법을 결정하는 관리자 역할

	- 응용 프로그램과 입출력장치 제어자

		- 컴퓨터 시스템을 부적절하게 사용하거나 오류가 발생하는 것을 방지하려고<br>하드웨어 사용을 조정하고 응용 프로그램의 실행을 제어
		- 특히 입출력장치를 동작시키고 통제하는 핵심 역할을 함

<br>

- 커널
	- 시스템 호출, 인터럽트 및 예외에 응답하는 운영체제의 핵심 구성 요소
	- 운영체제를 메모리에 적재할 때 제일 먼저 적재하고 운영체제가 종료될 때까지 메모리메 남아있음
		- 메모리에 남아있기 때문에 커널은 가능한 작게 구현하는 것이 좋음

<br>

# 운영체제의 발전 목적

<br>

![p](/Jake2580/chapter2/image/p2-3.png)

운영체제의 발전 목적

<br>

- 신뢰도
	- 하드웨어(펌웨어), 소프트웨어가 실패 없이 주어진 기능을 수행할 수 있는 능력
- 사용 가능도
	- 가동률이라고도 함
	- 고장으로 보수한 기간은 제외
	- 고장과 오류가 발생해도 그 영향을 최소화하여<br>시스템을 중단하지 않고 운영할 수 있어야 함

<br>

# 운영체제의 기능

<br>

![p](/Jake2580/chapter2/image/p2-4.png)

운영체제의 기능

<br>

### 자원 관리

<br>

컴퓨터 시스템의 메모리, 프로세스, 장치, 파일 등 구성 요소를 자원이라고 하는데, 운영체제는 이 자원을 관리한다.

<br>

![p](/Jake2580/chapter2/image/p2-5.png)

운영체제의 자원 관리 기능

<br>

- 메모리 관리
	- 메인 메모리 관리
		- 메모리의 어느 부분을 사용하고 누가 사용하는지 점검
		- 메모리에 저장할 프로세스를 결정
		- 메모리를 할다아고 회수하는 방법을 결정
	- 보조기억장치 관리
		- 빈 여유 공간을 관리
		- 새로운 파일을 작성할 때 저장 장소를 할당
		- 메모리 접근 요청을 스케줄링함
		- 파일 생성, 삭제

<br>

- 프로세스 관리
	- 프로세스와 스레드를 스케줄링함
	- 사용자 프로세스와 시스템 프로세스를 생성, 삭제
	- 프로세스를 중지하고 재수행
	- 프로세스 동기화 방법을 제공
	- 프로세스 통신 방법을 제공
	- 교착 상태(deadlock)를 방지하는 방법을 제공

<br>

- 주변장치 관리
	- 임시 저장(buffer-caching) 시스템 기능을 제공
	- 일반 장치용 드라이버 인터페이스를 제공
	- 특정 장치 드라이버를 제공

<br>

- 파일 관리
	- 파일 생성, 삭제
	- 디렉토리 생성, 삭제
	- 보조기억장치에 있는 파일을 맵핑함
	- 안전한(비휘발성) 저장장치에 파일을 저장

<br>

### 시스템 관리

<br>

- 시스템 보호
	- 파일 사용 권한 부여, 데이터 암호화 등 서비스를 제공
	- 여러 프로세스를 동시에 실행할 수 있으므로 서로 보호해야 함
	- 네트워크로 파일 공유 사이트에 접속할 때는 다른 사용자의 프로그램에서 보호해야 함

<br>

- 네트워킹
	- 연결된 프로세서가 통신할 때는<br>경로 설정, 접속 정책, 충돌, 보안 등 문제를 고려해야 함

<br>

- 명령 해석기(command interpreter)
	- 운영체제에서 중요한 시스템 프로그램
	- 사용자가 입력한 명령을 명령 해석기가 운영체제에 전달
	- 명령해석기는 보통 커널과 분리하는 것이 좋음
		- 명령 해석기를 커널에서 분리하면 명령 해석기의 인터페이스를 변경할 수 없음
		- 분리하지 않으면 사용자가 커널의 코드를 변경할 수 없어 인터페이스를 변경할 수 없음
		- 명령 해석기가 커널의 일부이면 비정상 프로세스가<br>커널의 특정 부분에 접근할 수 있으므로 커널에서 분리하는 것이 좋음

<br>

### 운영체제의 일괄 처리

<br>

- 일괄(Batch) 처리
	- 일괄 처리는 직렬 처리 기술과 동일
	- 사용자가 펀치 카드와 같은 오프라인(off-line) 장치에<br>작업을 저장하여 처리 시스템인 오퍼레이터 제출
		- 그러면 오퍼레이터에서 비슷한 작업들을 그룹으로 묶어 함께 일괄 처리함
	- 작업 준비 시간을 줄이려고 데이터가 발생할 때마다 즉시 처리하지 않고<br>데이터를 일정 기간 또는 일정량이 될 때까지 모아 두었다가 한꺼번에 처리함
		- ex) 포트란, 코볼, 포트란 순으로 작업을 수행해야 한다고 하자.<br>이때 포트란 포트란 코볼 순으로 처리하면<br>포트란에서는 단 한 번만 준비 작업을 하면 되므로 준비 사긴이 줄일 수 있다.
	- 많은 사용자와 프로그램이 컴퓨터 자원을 공유할 수 있음
	- 컴퓨터 자원을 덜 사용 중일 때는 작업 처리 시간을 교대할 수 있음
	- 시시각각 수동으로 개입하고 감독하여 컴퓨터 자원의 유휴를 피할 수 있음

<br>

![p](/Jake2580/chapter2/image/p2-6.png)

일괄 처리

<br><br><br>

- 버퍼링(buffering)
	- 프로세서와 입출력장치의 속도 차이로 생긴 유휴시간이 없도록 입출력장치별로 입출력 버퍼를 두어<br>프로세서에서 연산을 할 때 동시에 다른  작업을 입출력하는 아주 간단한 방법

<br>

- 버퍼
	- 프로세서가 어떤 작업을 처리하는 동안<br>버퍼에 다음으로 처리할(또는 출력할) 작업을 미리 읽어 저장해 두는 메모리

<br>

![p](/Jake2580/chapter2/image/p2-7.png)

버퍼링

<br><br><br>

- 스풀링(spooling)
	- 속도가 빠른 디스크를 버퍼처럼 사용하여 입출력장치에서 미리 읽는 것
	- 버퍼링이 컴퓨터 하드웨어의 일부인 버퍼를 사용한다면<br>스풀링은 별개의 오프라인 장치를 사용한다는 점
	- 버퍼링이 하나의 입출력 작업과 그 작업의 계산만 함께 할 수 있는 반면에<br>스풀링은 여러 작업의 입출력과 계산을 함께 할 수 있음
	- 성능에 직접적으로 도움을 줌
	- 프로세서와 입출력장치가 고효율을 작업할 수 있도록 함

<br>

![p](/Jake2580/chapter2/image/p2-8.png)

스풀링

<br><br><br>

### 서버 가상화

<br>

- 서버 가상화
	- 1960년대 후반 등장한 가상화(virtualization) 기술이 본격적으로 확산됨
	- 물리적 자원을 추상화하여 논리적 자원 형태로 표현하는 기술
	- 처음 등장했을 때는 도입 비용이 비싸고 사용 환경이 제한적이라 많이 사용하지 않음
		- 그러다 기술 발달로 경제성이 높아지면서<br>성능, 안정성, 효율성 향상 등 강점으로 본격적으로 확산됨

<br>

- 가상화
	- 서버 가상화
		- 운영체제와 관련된 가상화 핵심
		- 물리적 서버 하나에 가상 서버를 여러 개 구성하는 방법
	- 데스크톱 가상화
	- 스토리지 가상화
	- 네트워크 가상화
	- 소프트웨어 가상화

<br>

![p](/Jake2580/chapter2/image/p2-9.png)

서버 가상화의 개념

<br><br><br>

- 호스트 기반 가상화
	- 가상화 방법에 따라 호스트 운영체제에서 가상 머신을 구동
	- 설치가 쉽고 구성이 편함
	- 성능이 떨어질 수 있다는 단점이 존재

<br>

![p](/Jake2580/chapter2/image/p2-10-a.png)

호스트 기반 가상화

<br><br><br>

- 베어메탈(bare-metal) 기반 가상화
	- 호스트 운영체제 설치 전에 가상화 솔루션을 탑재하여<br>가상의 CPU, 메모리, 디스크, 네트워크 카드 등을 생성
	- 향상된 성능을 제공
	- 실시간 운영체제를 지원할 수 있다는 장점
	- 운영체제 위에 없기 때문에<br>디바이스용 드라이버, 하드웨어 플랫폼 드라이버 등을 포함해야 하고<br>설치와 구성이 어렵다는 단점이 존재

<br>

![p](/Jake2580/chapter2/image/p2-10-b.png)

베어메탈 기반 가상화

<br><br><br>

- 클라우드 컴퓨팅
	- 서버 가상화 기술을 이용하여<br>사용자에게 컴퓨팅 자원, 스토리지, 소프트웨어 등을 서비스 형태로 제공
	- 그리드(grid) 컴퓨팅,<br>유틸리티(utility) 컴퓨팅,<br>서버 기반(server based) 컴퓨팅의 특징을 조금씩 차용한 개념
	- 그리드 컴퓨팅의 분산 컴퓨팅 개념,<br>유틸리티 컴퓨팅의 과금 모델,<br>서버 기반 컴퓨팅의 처리 모델을 적용
		- 클라우드 데이터 센터에서 원하는 만큼 컴퓨터 자원을 무한대로 사용할 수 있음
		- 컴퓨터 자원을 원할 때 원하는 만큼 늘리거나 줄일 수 있음
		- 컴퓨터 자원을 사용한 만큼 사용료를 지불

<br>

- 클라우드 컴퓨팅 기술을 이용한 서비스
	- IaaS(Infrastructure as a Service)
		- 데이터 센터에 있는 서버, 스토리지, 네트워크 등 인프라나 자원을 가상화하여 인터넷으로 제공
			- 아마존 EC2(Elastic Cloud Computing)
				- 개인의 가상 인스턴스를 생성, 관리, 실행하는 서비스
			- 아마존 S3(Simple Storage Service)
				- 데이터를 저장하는 개인 스토리지 제공 서비스
	- PaaS(Platform as a Service)
		- 응용 프로그램의 구축, 테스트 및 설치가 가능한 통합 개발 환경을 웹으로 제공
			- 다음, 네이버에서 제공하는 Open API가 PasS의 일종
	- SaaS(Software as a Service)
		- 특정 소프트웨어를 인터넷으로 제공
		- 해당 소프트웨어와 관련된 데이터를 클라우드에서 관리
		- 사용자는 웹 브라우저로 접속하여 소프트웨어를 사용
		- 온디맨드(on demand) 소프트웨어라고도 부름

<br>

### 운영체제의 유형

<br>

- 단일 작업(single tasking)
	- 한 번에 하나의 프로그램만 수행
		- ex) 도스
- 다중 작업(multitasking)
	- 대부분 동시에 2개 이상의 프로그램을 수행할 수 있음
		- ex) 현재 사용하는 운영체제

<br>

![p](/Jake2580/chapter2/image/p2-11.png)

운영체제의 유형

<br><br><br>

- 다중 프로그래밍 시스템
	- 일괄 처리 시스템의 가장 큰 문제는 프로세스가 다른 작업을 하고 있을 때<br>입출력 작업이 불가능하여 프로세서와 메인 메모리의 활용도가 떨어졌지만<br>다중 프로그래밍을 도입하여 해결함
	- 프로세서가 유휴 상태일 때 실행 중인 둘 이상의 작업이<br>프로세서을 전환(인터러빙)하여 사용할 수 있도록 동작함
	- 여러 프로그램을 메모리에 적재한 후<br>하나의 프로그램이 프로세서를 사용하다가 입출력 동작 등을 하여<br>프로세서를 사용하지 않는 유휴 시간(idle time) 동안<br>다른 프로그램이 프로세서를 사용하도록 하는 시스템

<br>

![p](/Jake2580/chapter2/image/p2-12.png)

다중 프로그래밍 시스템

<br>

![p](/Jake2580/chapter2/image/p2-13.png)

다중 프로그래밍 시스템의 처리 방법 예

<br><br><br>

- 시분할 시스템(TSS, Time Sharing System)
	- 다중 프로그래밍을 논리적으로 확장한 개념
	- 프로세서가 다중 작업을 교대로 수행
	- 다수의 사용자가 동시에 컴퓨터의 자원을 공유할 수 있는 기술
	- 1970년 초까지는 시분할 시스템을 만들기가<br>아주 어렵고 비용도 많이 들어 일반화하지는 못했으나<br>이제는 대부분 다중 프로그래밍과 시분할 방법을 모두 지원함

<br>

![p](/Jake2580/chapter2/image/p2-14.png)

시분할 시스템의 처리 방법 예

<br>

![p](/Jake2580/chapter2/image/t2-2.png)

시분할 시스템의 장점과 단점

<br><br><br>

- 다중 처리 시스템(Multiprocessing System)
	- 단일 컴퓨터 시스템 내에서 둘 이상의 프로세서를 사용하여<br>동시에 둘 이상의 프로세스(프로그램)을 지원함
	- 하나의 프로세서가 2개 이상의 프로그램을 전환하는 다중 프로그래밍과 혼동해서는 안 됨
	- 여러 프로세서와 시스템 버스, 클록, 메모리와 주변장치 등을 공유함
	- 프로세서가 둘 이상이므로 빠르고<br>프로세서 하나가 고장이 나도<br>다른 프로세서를 사용하여 작업을 계속할 수 있음

<br>

![p](/Jake2580/chapter2/image/p2-15.png)

다중 처리 시스템

<br><br><br>

- 실시간 처리 시스템(Real time processing System)
	- 더 높은 적시 응답을 요구하는 장소에서 사용하거나<br>데이터 흐름 또는 프로세서 연산에 엄격한 시간 요구가 있을 때 사용할 수 있음
- 경성(hard) 실시간 처리 시스템
	- 작업의 실행 시작이나 완료에 대한 시간 제약 조건을 지키지 못할 때<br>시스템에 치명적인 영향을 주는 시스템
		- ex) 무기 제어, 발전소 제어, 철도 자동 제어, 미사일 자동 조준 등이 이에 해당됨
		- 보장되는 컴퓨팅, 시간의 정확성과 컴퓨팅 예측성을 갖게 해야 함
- 연성(soft) 실시간 처리 시스템
	- 작업 실행에서 시간 제약 조건은 있으나<br>이를 지키지 못해도 전체 시스템에 치명적인 영향을 미치지 않는 시스템
		- ex) 동영상을 초당 일정 프레임 이상의 영상을 재생해야 한다는 제약이 있으나<br>일부 프레임을 건너뛰어도 동영상을 재생하는 시스템에는 큰 영향을 미치지 않음

<br><br><br>

- 분산 처리 시스템(distributed processing System)
	- 시스템마다 독립적인 운영체제와 메모리로 운영하며<br>필요할 때 통신하는 시스템
	- 사용자에게 중앙집중식 시스템처럼 보이는데<br>다수의 독립된 프로세서에서 실행함
	- 데이터를 여러 위치에서 처리, 저장하며<br>여러 사용자가 공유할 수 있음
	- 하나의 프로그램을 여러 프로세서에서 동시에 실행할 수 있음

<br>

![p](/Jake2580/chapter2/image/p2-16.png)

분산 처리 시스템

<br><br><br>

# 운영체제의 서비스

<br>

- 부팅 서비스
	- 컴퓨터 하드웨어를 관리하고 프로그램을 실행할 수 있도록 함

<br>

![p](/Jake2580/chapter2/image/p2-17.png)

부팅 과정

<br><br><br>

- 사용자 서비스
	- 프로그래머가 프로그래밍 작업을 쉽게 수행할 수 있도록 함
	- CLI(Command Line Interface, 명령 라인 인터페이스)
		- 명령어를 입력하여 시스템을 동작하게 하는 텍스트 전용 인터페이스
	- GUI(Graphical User Interface, 그래픽 사용자 인터페이스)
		- 그래픽 제어 요소를 사용하여 컴퓨터와 상호작용할 수 있는 가장 보편적인 유형

<br>

- 시스템 서비스
	- 시스템의 효율적인 동작을 보장
	- 여러 사용자가 사용하는 시스템에서는 컴퓨터 자원을 공유하여<br>시스템 자체의 효율성을 높일 수 있음

<br>

- 시스템 호출
	- 프로그램이 운영체제 기능을 서비스 받을 수 있는 프로그램과 운영체제 간의 인터페이스를 제공
	- API(Application Programming Interface)라고도 함
		- ex) Win32 API, 유닉스 등 포식스 API, 자바 API 등이 있음
		- 사용자 프로그램은 시스템 호출을 하여 운영체제의 기능을 제공받음
		- 응용 프로그램이 사용자 수준에서 지원하지 않는 기능을 운영체제의 루틴을 호출하여 제공받는 방법
	- 핵심 커널 서비스와 통신,<br>새로운 프로세스의 생성과 실행,<br>하드웨어 관련 서비스 등이 있음
	- 시스템 호출 방법에는 두 가지가 있음
		1. 프로그램에서 명령이나 서브루틴의 호출 형태로 호출
			- 보통은 어셈블리어로 제공하지만<br>고급 언어(C, C++)로 작성한 프로그램에서 직접 수행할 수도 있음<br>이때는 미리 정의된 기능이나 서브루틴 호출과 비슷함
		2. 시스템에서 명령 해석기를 사용하여 대화 형태로 호출
	- 일반적인 시스템 호출에는<br>프로세서 제어, 파일 조작, 장치 관리, 정보 유지 등이 있음

<br>

![p](/Jake2580/chapter2/image/t2-3.png)

운영체제의 시스템 호출 서비스

<br>

![p](/Jake2580/chapter2/image/p2-18.png)

시스템 호출

<br><br><br>

# 운영체제의 구조

<br>

- 단일 구조 운영체제
	- 초기에 생겨난 가장 보편적인 형태
	- 운영체제의 모든 기능을<br>커널과 동일한 메모리 공간에 적재한 후<br>시스템 호출만으로 사용할 수 있음

<br>

![p](/Jake2580/chapter2/image/p2-19.png)

단일 구조 운영체제 : 도스

<br>

![p](/Jake2580/chapter2/image/p2-20.png)

단일 구조 운영체제 : 초기 유닉스

<br>

- 초기 유닉스 → 단일 커널 구조
	- 커널의 여러 기능을 분할하는 형태로 개발
	- IBM 버전의 AIX는 커널을 영역 2개로 분리
	- 단일 구조 운영체제는 대부분의 기능을 커널에 그룹화해서 구현하므로<br>직접 통신하여 시스템 자원을 효율적으로 관리할 수 있다는 장점이 있음
	- 커널 크기가 상대적으로 커지면서 버그의 원인이나 기타 오류를 구분하기 어렵고<br>새 기능을 추가하는 수정과 유지 보수가 매우 어려움
	- 동일한 메모리에서 실행하므로 한 부분에서 발생한 문제 때문에<br>시스템 전체에 심각한 영향을 줄 수 있다는 단점이 있음
	- 최근 빈번하게 발생하는 악성 코드로 피해를 입기 쉬움

<br>

![p](/Jake2580/chapter2/image/p2-21.png)

단일 커널 구조

<br><br><br>

- 계층 구조 운영체제
	- 운영체제가 점점 커지고 복잡해지면서<br>순수 단일 구조만으로는 다루기가 어려워져<br>이 문제를 해결하기 위해 계층 구조 운영체제가 만들어짐

<br>

![p](/Jake2580/chapter2/image/p2-22.png)

계층 구조 운영체제 예 : THE 운영체제

<br><br><br>

- 마이크로 커널 구조 운영체제
	- 단일 커널의 문제점을 해결하려고<br>1980년대 카네기멜론대학교에서는<br>모듈화된 마이크로 커널을 사용하여 매크(Mach)를 만듦
	- 마이크로 커널은 커널의 기능을 많이 제외시킴
	- 커널에서는 최소 기능만 포함시켜<br>크기를 대폭 줄이고 기타 기능은 사용자 공간으로 옮겨<br>사용자 영역에서 구행하는 서버 구현 방법
	- 운영체제 서비스를 사용자 영역의 독립적인 서버에서 수행하기 때문에<br>서버에서 잘못 수행하더라도 다른 서버와 커널에 치명적인 영향을 주지 않음
	- 운영체제의 많은 기능을 사용자 영역의 서버로 구현할 수 있기 때문에<br>서버개발이 용이하고 운영체제의 기능을 쉽게 변경할 수 있음
	- 모듈화 정도가 높아 확장성, 이식성, 규모 확장성이 높지만<br>모듈 간에 통신이 빈번하게 발생하여 성능이 떨어질 수 있음
	- 프로세스 간 통신 발생을 최소화시키는 것이 중요 과제
		- ex) 파일을 사용하려는 사용자 프로세스는<br>파일 서버 프로세스에 메시지를 보내고 작업을 수행한다.<br>그런 다음 다시 메시지로 사용자 프로세스에 회신하는 형식으로<br>서비스를 사용하는 과정에서 여러번의 메시지 전송을 요구한다.<br>또 응용 프로그램과 서버 간에 자료를 교환하려고<br>커널을 출입하는 문맥 교환 때문에 속도가 느리다.<br>그러나 커널 내부에서 발생 지역이 적고 예측 가능하여 실시간 시스템에 활용한다.<br>대표적인 운영체제 중 마이크로 커널 구조를 전적으로 선택한 것은 없지만<br>모듈화된 구성 요소는 포함한다.

<br>

![p](/Jake2580/chapter2/image/p2-23.png)

마이크로 커널 구조

<br><br><br>
