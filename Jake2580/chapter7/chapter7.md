# 메모리

<br>

- 메모리
	- 프로그램을 실행하는 중요한 작업 공간

<br>

- 메모리 관점
	- 논리적 주소
		- 프로그래머는 프로그래밍시<br>논리적 관점의 논리적 주소로 메모리를 바라봄
	- 물리적 주소
		- 실제 데이터나 프로그램을 저장하는 공간으로<br>논리적 주소에 대응하여 적재하는 실제주소를 의미

<br>

- MMU
	- CPU가 메모리에 접근하는 것을 관리하는 하드웨어 부품으로<br>논리적 주소를 실제 메모리주소로 변환 등을 담당

<br>

![MMU](/Jake2580/chapter7/image/MMU.jpg)

<br>

- 메모리 적재 방법
	- 연속 메모리 적재 방법
		- 연속 메모리 적재는 직접 배치, 오버레이, 고정분할 등으로 할 수 있음
			- 고정분할
				- 모두 같은 크기의 메모리로 할당하는 방법
				- 대신 메모리를 낭비하게 됨(외부/내부 단편화를 초래함)
	- 분산(비연속) 메모리 적재 방법
		- 프로그램 하나가 물리적 주소의 여러 공간에 분산해 올라가는 기법
		- 고정분할(페이징), 가변분할(세그먼테이션)

<br>

![메모리 할당 방법](/Jake2580/chapter7/image/메모리_할당_방법.jpg)

# 페이징

<br>

- 페이징
	- 작업을 크기가 동일한 페이지로 나눠 처리하는 방법
	- 물리 메모리는 Page Frame(페이지 프레임)<br>논리 메모리는 Page(페이지) 단위로 나눌 수 있음
	- 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고<br>물리 메모리의 남는 Page Frame에 적절히 배치됨으로 외부 단편화를 해결 가능함
	- 단점은 내부 단편화 문제 발생 가능성이 큼
		- 페이지 크기가 1000 바이트, 프로세스 A의 메모리 요구 크기가 3010 바이트라 가정하면<br>물리 메모리 내 4개의 페이지 프레임이 사용되고 그 중 한 개는 990(1000 - 10) 바이트 만큼의<br>여유 공간이 남게 됨(= 내부 단편화)

<br>

- 페이지 테이블(Page Table)
	- 운영체제는 프로세스마다 페이지 테이블 이라는 자료구조를 유지함
	- 하나의 프로세스는 하나의 페이지 테이블을 가짐
	- 페이지 테이블은 페이지 테이블 엔트리(Entry)라는 페이지 정보를 저장함
	- 페이지 테이블 엔트리의 Key는 페이지 번호, Value는 물리 메모리의 시작 주소임
	- CPU에서 논리 주소를 보내면 페이지 테이블을 통해 물리 메모리의 시작 주소를 찾음

<br>

- 페이지 테이블(Page Table) 변환 과정
  1. 가상 주소가 물리 메모리 주소로 변환 되어야할 때, 테이블 정보들이 저장되어 있는<br>TLB(Translation Lookaside Buffer)라는 연관 캐시를 검색함
  2. TLB에서 검색을 성공하면 물리 메모리 주소를 반환하여 프로세스는 해당 주소로 접근이 가능함
  	- 만약 검색에 실패하면<br>해당 가상 주소에 Mapping된 물리 메모리 주소가 있는지 Page Table에서 검색하고<br>찾으면 TLB에 Update하고 (1)부터 다시 진행함
  3. Mapping 데이터를 찾지 못한 경우
  	- 가상 메모리 주소 자체가 유효하지 않은 경우<br>→ Segmentation Fault 발생
  	- 해당 가상 메모리 주소가 물리 메모리에 존재하지 않는 경우<br>→ 페이지가 다른 메모리 접근 요청에 의해 공간이 부족해져서 Page-Out된 상황

<br>

- 페이지 부재(Page Fault)
	1.  페이지 테이블 변환 과정에서<br>Mapping 데이터를 찾지 못하고<br>물리 메모리 공간이 부족해져서 Page-Out이 발생되면<br>운영체제는 페이지 부재를 발생시킴
	2. 해결 방법
		- 물리 메모리가 꽉 차지 않았다면<br>Paging 파일에 존재하는 데이터를<br>물리 메모리에 존재하는 Empty Frame으로 Load하면서<br>Page Table과 TLB 내용을 갱신함
		- 물리 메모리에 Empty Frame이 존재하지 않는다면(= 여유 메모리 공간이 없다면)<br>물리 메모리에서 Empty Page로 변경할 Page를 찾은 후 해당 Page를 Empty Frame으로 변환함
			- 그 후에 Load하려는 데이터를 Empty Frame으로 Load하면서 Page Table과 TLB 내용을 갱신함
			- 이 경우에는 Page-Out된 Page에 대한 제거 과정도 포함

<br>

- 페이징 알고리즘(Paging Algorithm)
	- Page Fault가 발생했을 때 모든 Page Frame이 사용중이라면<br>어떤 Page Frame을 선택하여 교체할 것인지를 결정하는 알고리즘

<br>

# 세그먼테이션(Segmentation)

<br>

- 세그먼테이션
	- 페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌<br>서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할하는 방법
	- 사용자가 두 개(세그먼트 번호 + 변위)의 주소로 지정함
	- 세그먼트 테이블에는<br>각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장
	- 단점은 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면<br>자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있음(= 외부 단편화)

<br>

- 단편화
	- 외부 단편화
		- 메모리 공간 중 일부 사용 못하게 되는 부분이 발생
		- 물리 메모리(RAM)에서 사이사이 남는 공간들을 합치면<br>충분한 공간이 되는 부분들이 분산되어 있을 때 발생함
	- 내부 단편화
		- 프로세스가 사용하는 메모리 공간에 포함된 남은 부분
		- 예시
			- 메모리 분할 자유 공간이 10,000B 있고<br>프로세스 A가 9,998B를 사용하게 되면<br>2B라는 여유 공간이 남게 되는 현상

<br>

- 압축 작업
	- 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아<br>자유 공간을 확보하는 방법론이지만 작업 효율이 좋지 않음

<br>
