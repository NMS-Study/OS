# 가상 메모리

<br>

- 가상 메모리
	- 물리 메모리 크기의 한계를 극복하기 위해 나온 기술
	- 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용
		- 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행
		- 실행에 필요한 부분만 메모리에 올림
			- 실행에 필요한 부분이 페이지 단위일 수도 있고<br>세그먼트 단위일 수도 있지만 현재 대부분은 페이지 단위를 사용
			- 이처럼 현재 요구 되는 페이지만 메모리에 올리는 것을<br>요구 페이징(Demand Paging) 이라고 함

<br><br><br>

# 요구 페이징

<br>

- 요구 페이징
	- 프로세스를 페이지 단위로 잘라서 메모리에 올리는데<br>요구되는 페이지만 메모리에 올리고 필요하지 않는 페이지들은<br>backing store(하드 디스크)에 저장해주는 것
		- 프로세스 이미지는 backing store에 저장
		- 프로세스는 페이지의 집합
		- 필요한(Demand) 페이지만 메모리에 올림(Load)

<br>

- 페이지 부재
	- CPU에서 요청한 페이지가 현재 메모리에 없어서<br>유효-무효 비트가 무효로 세팅되어 있는 경우
	- 페이지 부재가 발생하면<br>backing store에 있는 것을 읽어오는 과정에서<br>막대한 오버헤드가 발생하기 때문에<br>이 기법은 발생률에 따라 성능에 큰 영향을 끼침

<br>

- 페이지 부재 동작 과정
	- MMU(Memory management unit)가 페이지 부재 트랩을 발생
		- 트랩(소프트웨어 인터럽트)
	- 인터럽트로 인해 커널모드로 전환되어 OS의 페이지 부재 처리 루틴이 호출됨
	- 해당 부재 페이지의 보호 비트를 참조해 접근이 가능한지 체크
	- 물리 메모리에 비어있는 프레임을 할당받고 그곳에 페이지를 읽음
	- 페이지를 읽어오는 동안 프로세스는 대기(wait)상태가 됨
	- 디스크 입출력 완료시 인터럽트를 발생시키고<br>해당 페이지의 유효-무효 비트를 유효로 세팅

<br><br><br>

# 페이지 대치(교체)

<br>

- 페이지 대치
	- 페이지 부재가 일어나서 해당 페이지를 적재해야 하는 상황에 메모리에 여유가 없을 때<br>메모리에 있는 페이지 중 가장 쓸모 없어보이는 것을 골라 스왑 영역으로 쫒아내고<br>그 자리에 페이지 부재된 페이지를 적재하는 것

<br>

- 페이지 대치 알고리즘
	- FIFO(First-in First-out)
		- 선입선출 알고리즘
		- 메모리에 먼저 올라온 페이지를 먼저 내보냄
	- OPT(Optimal Page Replacement)
		- 최적 페이지 대치 알고리즘
		- 앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄
	- LRU(Least Recently Used)
		- 최근 최소 사용 대치 알고리즘
		- 가장 오랫동안 참조되지 않은 페이지를 가장 먼저 내려보냄
	- LFU(Least Frequently Used)
		- 최근 최소 사용 근접 알고리즘
		- 가장 적은 참조횟수를 갖는 페이지를 가장 먼저 내려보냄
	- NUR(Not Used Recently)
		- 최근에 사용되지 않은 것을 교체하는 알고리즘
		- 페이지 프레임의 참조 비트를 조사해서<br>참조 비트가 0인 페이지를 찾으면 그 페이지와 교체
		- LRU처럼 오랫동안 참조되지 않은 페이지중 하나를 선택하지만<br>가장 오래된 페이지라는 보장은 없음

<br><br><br>

# 스레싱

<br>

- 스레싱
	- 프로세스의 처리 시간보다<br>페이지 교체에 드는 시간이 더 많아져서<br>CPU 이용률이 떨어지는 현상
	- 다중 프로그래밍의 정도가 높아지면<br>프로세스가 메모리안에 동시에 올라갈 수 있는 수가 높아지면서<br>어느정도 까지는 CPU 이용률이 오르겠지만<br>한계치를 넘으면 스레싱이 발생하고 CPU 이용률이 급감함

<br>

- 해결책
	- 다중 프로그래밍 정도를 적정 수준으로 유지
	- 페이지 부재 빈도 조절
	- working set을 유지
	- 일부 프로세스를 중단