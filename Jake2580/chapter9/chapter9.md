# 입출력 시스템

<br>

- 폴링(Polling)
	- 프로세서가 주기적으로 입출력 장치의 상태 확인
	- 구현이 쉽고 우선순위 변경이 용이함
	- 리소스를 많이 먹는다는 단점이 있음

<br>

- 인터럽트(Interrupt)
	- 입출력 장치가 작업을 완료한 뒤에 자신의 상태를 프로세서에게 전달
	- 인터럽트가 발생하면 프로세서는 데이터 전송 수행
	- 구현이 복잡함
	- 시그널이 들어온 정확한 타이밍을 알 수 있어서 반응 시간이 빠름
	- 인터럽트가 발생했을 때만 처리하기 때문에 시스템 부하가 적음

<br>

![interrupt](/Jake2580/chapter9/image/interrupt.png)

<br>

- 예시(스위치가 눌러졌을 때)
	- 폴링
		- Loop 내부에서 일정 시간 간격으로<br>IF문을 통해 스위치가 눌렸는지 확인하고 LED를 켜줌
	- 인터럽트
		- 스위치가 눌리면 인터럽트가 발생하여 LED를 켜줌

<br>

- Direct Memory Access(DMA)
	- 입출력 장치와 메모리 사이의 데이터 전송을 프로세서 개입 없이 수행
		- 프로세서의 도움 없이도 메인 메모리를 직접 제어하여<br>데이터를 전송하는 형태를 DMA(직접 메모리 엑세스)라고 함
	- 프로세서가 데이터 전송과 관리를 담당하므로 프로세서의 부담이 적음

<br>

![dma](/Jake2580/chapter9/image/dma.png)

<br><br><br><br><br><br>

# 디스크 스케줄링

<br>

- 디스크 스케줄링의 목적
	- 처리량 최대화
	- 응답 시간 최소화
	- 응답 시간 편차의 최소화

<br><br><br>

- 버퍼링
	- 입출력 장치와 프로그램 사이에 전송되는 데이터를<br>버퍼에 임시 저장함
	- 전송 속도 (or 처리 단위) 차이 문제 해결

<br>

<img src="/Jake2580/chapter9/image/buffering.png" alt="buffering" style="zoom: 80%;" />

<br><br><br>

- 선입 선처리 스케줄링(FCFS, First Come First Served)
	- 요청이 도착한 순서에 따라 처리됨
	- 프로그램하기 쉽고 어떤 요청도 무기한 연기되는 경우가 없으며<br>본질적으로 공평성이 유지됨
	- Disk access 부하가 적은 경우에 적합
	- 문제는 디스크 요청이 흩어져 있는 경우에는<br>실행시간 오버헤드는 적으나<br>탐색시간이 오래 걸려서 처리량이 감소함

<br>

총 256개의 실린더로 구성<br>큐 : 160, 200, 90, 170, 20, 190, 120, 130<br>헤드 시작 위치 : 100

| 큐   | 탐색 거리 |
| ---- | --------- |
| 160  | 60        |
| 200  | 40        |
| 90   | 110       |
| 170  | 80        |
| 20   | 150       |
| 190  | 170       |
| 120  | 70        |
| 130  | 10        |

총 탐색 거리 : 690

<br><br><br>

- 최소 탐색 시간 우선 스케줄링(SSTF, Shortest Seek Time First)
	- 디스크 요청을 처리하기 위해서 헤드가 먼 곳까지 이동하기 전에<br>현재 헤드 위치에 가까운 모든 요구를 먼저 처리하는 방법
	- 일괄 처리 시스템에 적합
	- 문제는 디스크 처리 시간을 실질적으로 줄일 수 있지만<br>디스크 요구의 기아 상태 발생 가능

<br>

큐 : 160, 200, 90, 170, 20, 190, 120, 130<br>헤드 시작 위치 : 100

| 큐   | 탐색 거리   |
| ---- | ----------- |
| 90 | 10 |
| 120 | 30 |
| 130 | 10 |
| 160 | 30 |
| 170 | 10 |
| 190 | 20 |
| 200 | 10 |
| 20 | 180 |

총 탐색 거리 : 300

<br><br><br>

- 스캔(SCAN) 스케줄링
	- 현재 진행 중인 방향으로<br>가장 짧은 탐색 거리에 있는 요청을<br>먼저 서비스하는 기법
	- 진행 방향 반대쪽 끝의 요청들의 응답시간이 늘어남

<br>

큐 : 160, 200, 90, 170, 20, 190, 120, 130<br>헤드 시작 위치 : 100

| 큐   | 탐색 거리   |
| ---- | ----------- |
| 90 | 10 |
| 20 | 70 |
| 0 | 20 |
| 120 | 120 |
| 130 | 10 |
| 160 | 30 |
| 170 | 10 |
| 190 | 20 |
| 200 | 10 |

총 탐색 거리 : 300

<br><br><br>

- 순환 스캔 스케줄링(C-SCAN, Circular-SCAN)
	- 스캔 스케줄링을 변형
	- 대기 시간을 균등하게 함
	- 스캔 한쪽 방향으로 이동하면서 요청을 처리하고<br>끝에 다다르면 다시 처음부터 요청을 처리

<br>

큐 : 160, 200, 90, 170, 20, 190, 120, 130<br>헤드 시작 위치 : 100

| 큐   | 탐색 거리   |
| ---- | ----------- |
| 90 | 10 |
| 20 | 70 |
| 0 | 20 |
| 255 | 255 |
| 200 | 55 |
| 190 | 10 |
| 170 | 20 |
| 160 | 10 |
| 130 | 30 |
| 120 | 10 |

총 탐색 거리 : 490

<br><br><br>

- 룩(LOCK) 스케줄링
	- SCAN 기법을 사용하되<br>진행 방향의 마지막 요청을 서비스 한 후<br>바로 역방향으로 진행하는 기법
	- SCAN 기법의 불필요한 HEAD 이동 제거

<br>

큐 : 160, 200, 90, 170, 20, 190, 120, 130<br>헤드 시작 위치 : 100

| 큐   | 탐색 거리   |
| ---- | ----------- |
| 90 | 10 |
| 20 | 70 |
| 120 | 100 |
| 130 | 10 |
| 160 | 30 |
| 170 | 10 |
| 190 | 20 |
| 200 | 10 |

총 탐색 거리 : 260

<br><br><br>

## RAID(Redundant Array of Independent Disks)

<br>

- RAID
	- 자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템
		- RAID 0는 해당되지 않음
	- 하나의 원본 디스크와 같은 크기의 백업 디스크에 같은 내용을 동시에 저장하고<br>하나의 디스크가 고장 났을 때 다른 디스크를 사용하여 데이터를 복구

<br>

- RAID 0
  - Disk striping
  - 모든 디스크에 입출력 부하 균등 분배
  - 백업 기능 없음

<br>

<img src="/Jake2580/chapter9/image/raid_0.PNG" alt="raid_0" style="zoom:67%;" />

<br><br><br>

- RAID 1 (미러링)
	- 하나의 데이터를 2개의 디스크에 나누어 저장하여<br>장애 발생시 백업 디스크로 활용
	- 짝수 개의 디스크로 구성
	- 한 디스크에 장애가 생겨도 데이터 손실 없음
	- 가용 디스크 용량 = (전체 디스크 용량 / 2)

<br>

<img src="/Jake2580/chapter9/image/raid_1.PNG" alt="raid_1" style="zoom: 67%;" />

<br><br><br>

- RAID 3
	- RAID 0 + parity disk
		- Byte 단위 분할 저장
		- 모든 디스크에 입출력 부하 균등 분배
	- 한 디스크에 장애 발생 시<br>parity 정보를 이용하여 복구
	- Write 시 parity 계산 필요
		- 오버헤드
		- Write가 몰릴 시 병목현상 발생 가능

<br>

<img src="/Jake2580/chapter9/image/raid_3.PNG" alt="raid_3" style="zoom:90%;" />

<br><br><br>

- RAID 4
	- RAID 3과 유사함
		- Block 단위로 분산 저장
		- 독립된 access 방법
	- 디스크간 균등 분배가 안될 수도 있음
	- 한 디스크에 장애 발생 시 parity 정보를 이용하여 복구
	- Write 시 parity 계산 필요
		- 오버헤드
		- Write가 몰릴 시 병목현상 발생 가능
		- 병목 현상으로 성능 저하 가능

<br>

<img src="/Jake2580/chapter9/image/raid_4.PNG" alt="raid_4" style="zoom:80%;" />

<br><br><br>

- RAID 5
  - RAID 4와 유사
    - 독립된 access 방법
  - 패리티 비트를 여러 디스크에 분산하여 보관함으로써<br>패리티 비트 디스크의 병목 현상 완화
  - 현재 가장 널리 사용 되는 RAID Level 중 하나

<br>

<img src="/Jake2580/chapter9/image/raid_5.PNG" alt="raid_5" style="zoom:80%;" />

<br><br><br>
