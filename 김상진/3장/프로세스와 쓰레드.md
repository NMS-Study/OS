# 프로세스와 스레드

# 용어 정리

## Job(Program)

디스크에 저장되어있는 데이터를 말한다. Job이 실행되어 메모리에 적재되고 시스템(커널)에 등록되면 프로세스가 된다

<br>

## 프로세스(Process)

- 커널에 의해 관리됨
  - 커널에 의해 할당되어지고 반납되는 개체임
- 프로그램을 실행해달라고 커널(시스템)에 요청하여 메모리에 적재 되면 프로세스가 된다

<br>

## 스레드(Thread)

- 프로세스의 실행 단위이다
- 하나의 프로세스는 여러개의 스레드를 가질 수 있는데 스레드들은 프로세스에 저장된 힙, 스태틱, 코드 영역에 있는 데이터를 공유 할 수 있다.
- 각각의 스레드들은 독립적인 스택영역과 레지스터를 가지며 이는 각각의 스레드가 독립적인 실행 흐름을 가진다는 것을 의미한다.

<br>

## 프로세서(Processor)

- 쉽게 말해 CPU 이다
- 메모리에 올라온 프로세스들을 처리하는 역할

<br>

## PCB(Process Control Block)

- 운영체제가 프로세스 관리에 필요한 정보를 저장하는 공간
- 프로세스가 생성되면 만들어진다

<br>

### PCB가 관리하는 정보

- 프로세스 ID
- 프로세스의 상태 정보
- 프로그램 카운터: 다음에 실행할 명령어의 주소
- 레지스터 블록
- CPU 스케쥴링 정보: 우선순위, 최종 실행시각, CPU 점유시간 등
- 메모리 관리 정보
- 프로세스 계정 정보
- IO 상태 정보

<br>

---

# 프로세스의 상태

![Untitled](https://user-images.githubusercontent.com/23889744/136552758-5d6a7e58-495e-41da-a055-cf8019a973c8.png)

![Untitled 1](https://user-images.githubusercontent.com/23889744/136552793-350c5e10-55b6-47e9-94a2-edd15bf15908.png)

<br>

- Primary States
  - Created(new)
    - 프로세스가 처음으로 생성됬을때 이를 Created 상태라고 함
    - **아직 메모리를 할당받지 못한 상태**
  - Ready(waiting)
    - 프로세스가 메모리를 할당 받은 상태이고 CPU에서 실행을 기다리고 있는 상태이다
    - 하나의 프로세스만 존재하는 시스템에서는 한번에 하나의 프로세스만 실행 할 수있고 나머지 프로세스들은 Queue에 보관된다
  - Running(dispatch)
    - 프로세스가 CPU에 의해 실행되어 지고 있는 상태이고 **CPU는 최대 하나의 프로세스를 실행** 할 수 있다
  - Blocked(sleep)
    - Running 상태에서 IO가 발생하면 **IO가 끝난 뒤** Ready 상태로 돌아가고 그 뒤에 다시 프로세스를 실행한다(Running)
  - Terminated
    - 프로세스가 종료된 상태를 의미한다 종료되면서 할당된 모든 자원을 반납한다
    - 커널은 종료된 프로세스의 정보를 PCB에 저장해놓고 다음에 같은 프로세스가 들어왔을때 좀 더 빠르게 처리 하기 위해 그 정보를 남겨놓는다
- Additional States
  - Swapped out and waiting(Suspended and waiting)
    - 프로세스의 상태가 Created가 되고나서는 Ready 상태로 가거나 Suspended and waiting 상태로 갈 수 있는데 Ready 상태로 갈수있는 조건은 사용 할 수 있는 메모리 공간이 남아있는 상태일때 Ready 상태로 갈 수 있다.
    - 반면 프로세스가 사용 가능한 메모리 공간이 남아있지 않을때는 Suspended and waiting 가 된다
  - Swapped out and blocked(Suspended and blocked)
    - 진행중이던 프로세스가 Blocked 된 상태에서 다른 프로세스에 의해 메모리 공간을 빼앗기고 남은 공간이 없을때 Suspended and blocked 상태가 된다
    - 이 상태에서 다시 메모리 공간을 할당 받으면 Blocked 상태가 되며, Suspended and blocked 상태의 프로세스가 기다리고 있던 자원이 할당 되는 경우 Suspended and waiting 상태가 된다

<br>

> _Suspended and waiting, Suspended and blocked 상태에서의 메모리 정보는 어디에 저장될까?_

<br>

프로세스는 메모리를 할당받지 못하면 Suspended and waiting 혹은 Suspended and blocked 상태가 된다. 이때 다른 프로세스가 메모리를 점유하게 되는데 메모리를 점유하는 과정에서 프로세스의 메모리 공간을 빼앗을 수도 있다. 이 말은 지연 상태(suspended)가 된 프로세스들의 작업 진행내역(메모리)이 사라진다는 소리이다. 다시 처음부터 작업을 진행해야 하는 비효율을 막기 위해 Swap Device 라는 곳에 Memory Image(작업 진행 내역)를 저장해 놓는다.

<br>

---

# 프로세스 구조

![Untitled 2](https://user-images.githubusercontent.com/23889744/136552888-5b154412-aa71-4c30-8be5-86314b340b26.png)

- 코드 영역: 프로그램을 실행시키기 위해 실행파일 내에 들어있는 명령어 집합을 메모리에 올려야 프로그램을 동작 시킬 수 있다 이 명령어들의 집합을 코드라고 한다(소스코드라고 보면된다)
- 데이터 영역: global 변수나 static 변수들이 저장되는 공간
- 스택 영역: 지역변수나 호출된 함수(함수의 인자포함) 가 저장되는 공간
- 힙 영역: 자바에서는 new 키워드로 만들어지는 객체들이 저장되는 공간(동적으로 생성되는 공간)

<br>

# 멀티 프로세스

![Untitled 3](https://user-images.githubusercontent.com/23889744/136552919-86ff58d7-e6a2-4111-acf4-d0af4f777ba0.png)

말 그대로 여러개의 프로세스를 의미한다. 하나의 작업을 여러개의 프로세스로 구성하는 경우가 있을 수 있는데, 이런 경우를 멀티 프로세스라고 한다.

멀티 프로세스를 활용한 작업은 몇가지 비효율이 발생하게 되는데 이를 프로세스의 특징으로 살펴보자면

- 각각의 프로세스는 독립된 메모리 공간에 코드, 데이터, 스택, 힙 데이터를 가지고 있기 때문에 **컨텍스트 스위칭시 비효율이 발생**한다.
- 프로세스끼리 데이터를 공유하기 위해서 **프로세스 간 통신이 필요**하다(IPC, Inter Process Communication)
  - 프로세스간 통신을 하지 않기 위해 쓰레드라는 개념이 탄생함
  - 쓰레드는 프로세스의 자원을 공유하기 때문임(통신할 필요 없음)

<br>

# 컨텍스트 스위칭(Context Switching)

## 멀티 프로세스 관점

CPU는 프로세스를 처리할때 레지스터(CPU 안에 있음, 레지스터 컨텍스트가 저장되어있음)와 메모리에서 코드, 데이터, 힙, 스택, PCB(PCB안에 레지스터 블록을 레지스터에 적재)를 참조한다.

<br>

> **_CPU는 연산만 담당한다. 정보를 저장하지 않는다._**

<br>

프로세스는 각각의 독립된 메모리 공간에 데이터를 저장하기 때문에 컨텍스트 스위칭이 일어날때 마다 메모리에 저장되어있는 프로세스 관련 정보를 다시 참조해야 한다.(코드, 데이터, 힙, 스택 정보를 다시 참조해야함. 이 과정에서 비용이 많이 든다) 같은 작업을 진행하면서 비효율적은 컨텍스트 스위칭이 많이 일어나는 것을 방지하기 위한 방법으로는 멀티 스레드를 사용하는 방법이 있다.

<br>

## 멀티 스레드 관점

멀티 스레드 방식으로 작업을 처리 한다면 멀티 프로세스와 마찬가지로 CPU의 레지스터 안에 레지스터 컨텍스트가 올라가게 되고, 메모리에서 프로세스의 코드, 데이터, 힙, 스택, PCB를 참조한다

다만, 멀티 스레드 환경에서 컨텍스트 스위칭이 일어난다면 멀티 프로세스 환경에서 교체 해줘야하는 자원들(코드, 데이터, 힙)을 다시 참조할 필요가 없다. 왜냐하면 스레드는 하나의 프로세스안에 여러개 생성 될 수 있는데 이 쓰레드들은 한 프로세스의 코드, 데이터, 힙 영역을 공유하기 때문이다. 교체 되는 자원들이 멀티 프로세스 환경보다 적기 때문에 멀티 스레드가 컨텍스트 스위칭에 드는 오버헤드가 더 적다고 할 수 있다.

스레드의 컨텍스트 스위칭이 일어날때에는 스택영역과 레지스터 컨텍스트만이 교체된다. 이유는 프로세스 안의 스레드는 각각의 독립적인 실행 흐름을 가지기 때문이다.

<br>

## 동시성과 병렬성

앞에서 설명한 멀티 프로세스, 멀티 스레드 관점에서는 코어(CPU)가 싱글 코어인 점에서 설명을 하였다.

멀티코어 관점에서는 어떻게 작업을 처리하는지 알아보기 전에 **동시성과 병렬성**을 이해해야 한다

<br>

### 동시성(Concurrently)

![Untitled 4](https://user-images.githubusercontent.com/23889744/136553033-1f80cc95-7b24-493a-8ba6-425306338d4f.png)

동시성을 위키피디아에서 참조하자면 여러 계산을 **동시에** 처리한다는 의미를 갖는다.

그림을 보면 한 프로세스안에 2개의 쓰레드를 하나의 코어가 처리한다고 하였을때 작업을 순차적으로 조금씩 조금씩 처리한다는 의미이다. 즉 코어 하나가 쓰레드를 갈아 끼워가면서 조금씩 작업을 수행한다는 것이다. 이 속도가 매우 빨리 이루어 지기 때문에 컴퓨터를 사용하는 사용자 입장에서는 여러 작업을 동시에 처리하는것으로 느껴진다.

동시성은 하나의 작업이 끝나지 않아도 또 다른 작업을 시작 할 수 있다는 것이다. 작업을 전환하는 기준은 여러가지가 있을것이다(ex. 스케쥴링, 시분할 등)

<br>

### 병렬성(Parallelism)

![Untitled 5](https://user-images.githubusercontent.com/23889744/136553065-44a2922a-dd98-4085-880a-d1c193ab2893.png)

마찬가지로 병렬성을 위키피디아에서 참조하자면 많은 계산(프로세스)의 실행이 **동시에** 수행된다는 의미이다.

병렬성에서도 **동시에** 라는 말로 설명을 하는데 위키피디아 영문 설명을 보자면 동시성은 **Concurrently** 이고, 병렬성은 **Parallelism 혹은 Simultaneously** 이다.

그림에서는 2개의 코어가 쓰레드를 하나씩 가지고서 작업을 처리하고 있다. 병렬성은 동시성과 똑같에 하나의 작업이 끝나지 않아도 다른 작업을 시작 할 수 있고, 같은 시간대에 여러개의 일을 동시에 진행 시킬 수 있다(우리가 이해하는 **동시에** 라는 뜻이다)

<br>

### 멀티코어 관점

여러대의 코어가 한 프로세스 안에 여러개의 쓰레드를 참조한다고 가정해보자

이때 참조된 쓰레드의 코드, 데이터, 힙 영역은 CPU 안에 있는 캐시(L2 캐시)에 올라가게 되고 각각의 코어들은 L2 캐시를 참조하여 데이터를 공유하게 된다. 마찬가지로 레지스터 컨텍스트도 올라가있는 상황이다.

멀티코어에서 쓰레드의 컨텍스트 스위칭이 일어나도 캐시에 코드,데이터,힙 영역이 들어가 있기 때문에 컨텍스트 비용이 적다. 추가로 2개의 코어에서 여러개의 작업을 동시에(이떄에는 Parallelism의 개념) 처리하기 때문에 싱글코어 보다 성능이 좋다.

<br><br>

---

# 참고

[Process state - Wikipedia](https://en.wikipedia.org/wiki/Process_state)

[레스토랑에 비유해서 알아보는 운영체제 - 재그지그의 개발 블로그](https://wormwlrm.github.io/2021/10/04/OS-Restaurant.html)

[[리눅스] 프로세스의 개념과 상태전이도](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=iamsjy17&logNo=70154247479)

[쓰레드(Thread)란 무엇인가?](https://goodgid.github.io/What-is-Thread/)

[동시성(Concurrency) 과 병렬성 (Parallelism) 올바른 개념 잡기](https://vagabond95.me/posts/concurrency_vs_parallelism/)
